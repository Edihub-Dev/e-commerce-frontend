import{c as Ne}from"./index-Bpx0OnSg.js";import{g as Ie}from"./react-BzrpNAyj.js";/**
 * @license lucide-react v0.545.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const $e=[["path",{d:"M10.733 5.076a10.744 10.744 0 0 1 11.205 6.575 1 1 0 0 1 0 .696 10.747 10.747 0 0 1-1.444 2.49",key:"ct8e1f"}],["path",{d:"M14.084 14.158a3 3 0 0 1-4.242-4.242",key:"151rxh"}],["path",{d:"M17.479 17.499a10.75 10.75 0 0 1-15.417-5.151 1 1 0 0 1 0-.696 10.75 10.75 0 0 1 4.446-5.143",key:"13bj9a"}],["path",{d:"m2 2 20 20",key:"1ooewy"}]],Me=Ne("eye-off",$e);var se={exports:{}},de;function Ce(){return de||(de=1,(function(ge,xe){(function(ne,ee){ge.exports=ee()})(self,()=>(()=>{var ne={86:(S,A)=>{A.keys=function(g,o={}){return o.symbols!==!1?Reflect.ownKeys(g):Object.getOwnPropertyNames(g)}},125:()=>{},362:(S,A)=>{Object.defineProperty(A,"__esModule",{value:!0}),A.TLDS=void 0,A.TLDS=["AAA","AARP","ABB","ABBOTT","ABBVIE","ABC","ABLE","ABOGADO","ABUDHABI","AC","ACADEMY","ACCENTURE","ACCOUNTANT","ACCOUNTANTS","ACO","ACTOR","AD","ADS","ADULT","AE","AEG","AERO","AETNA","AF","AFL","AFRICA","AG","AGAKHAN","AGENCY","AI","AIG","AIRBUS","AIRFORCE","AIRTEL","AKDN","AL","ALIBABA","ALIPAY","ALLFINANZ","ALLSTATE","ALLY","ALSACE","ALSTOM","AM","AMAZON","AMERICANEXPRESS","AMERICANFAMILY","AMEX","AMFAM","AMICA","AMSTERDAM","ANALYTICS","ANDROID","ANQUAN","ANZ","AO","AOL","APARTMENTS","APP","APPLE","AQ","AQUARELLE","AR","ARAB","ARAMCO","ARCHI","ARMY","ARPA","ART","ARTE","AS","ASDA","ASIA","ASSOCIATES","AT","ATHLETA","ATTORNEY","AU","AUCTION","AUDI","AUDIBLE","AUDIO","AUSPOST","AUTHOR","AUTO","AUTOS","AW","AWS","AX","AXA","AZ","AZURE","BA","BABY","BAIDU","BANAMEX","BAND","BANK","BAR","BARCELONA","BARCLAYCARD","BARCLAYS","BAREFOOT","BARGAINS","BASEBALL","BASKETBALL","BAUHAUS","BAYERN","BB","BBC","BBT","BBVA","BCG","BCN","BD","BE","BEATS","BEAUTY","BEER","BERLIN","BEST","BESTBUY","BET","BF","BG","BH","BHARTI","BI","BIBLE","BID","BIKE","BING","BINGO","BIO","BIZ","BJ","BLACK","BLACKFRIDAY","BLOCKBUSTER","BLOG","BLOOMBERG","BLUE","BM","BMS","BMW","BN","BNPPARIBAS","BO","BOATS","BOEHRINGER","BOFA","BOM","BOND","BOO","BOOK","BOOKING","BOSCH","BOSTIK","BOSTON","BOT","BOUTIQUE","BOX","BR","BRADESCO","BRIDGESTONE","BROADWAY","BROKER","BROTHER","BRUSSELS","BS","BT","BUILD","BUILDERS","BUSINESS","BUY","BUZZ","BV","BW","BY","BZ","BZH","CA","CAB","CAFE","CAL","CALL","CALVINKLEIN","CAM","CAMERA","CAMP","CANON","CAPETOWN","CAPITAL","CAPITALONE","CAR","CARAVAN","CARDS","CARE","CAREER","CAREERS","CARS","CASA","CASE","CASH","CASINO","CAT","CATERING","CATHOLIC","CBA","CBN","CBRE","CC","CD","CENTER","CEO","CERN","CF","CFA","CFD","CG","CH","CHANEL","CHANNEL","CHARITY","CHASE","CHAT","CHEAP","CHINTAI","CHRISTMAS","CHROME","CHURCH","CI","CIPRIANI","CIRCLE","CISCO","CITADEL","CITI","CITIC","CITY","CK","CL","CLAIMS","CLEANING","CLICK","CLINIC","CLINIQUE","CLOTHING","CLOUD","CLUB","CLUBMED","CM","CN","CO","COACH","CODES","COFFEE","COLLEGE","COLOGNE","COM","COMMBANK","COMMUNITY","COMPANY","COMPARE","COMPUTER","COMSEC","CONDOS","CONSTRUCTION","CONSULTING","CONTACT","CONTRACTORS","COOKING","COOL","COOP","CORSICA","COUNTRY","COUPON","COUPONS","COURSES","CPA","CR","CREDIT","CREDITCARD","CREDITUNION","CRICKET","CROWN","CRS","CRUISE","CRUISES","CU","CUISINELLA","CV","CW","CX","CY","CYMRU","CYOU","CZ","DAD","DANCE","DATA","DATE","DATING","DATSUN","DAY","DCLK","DDS","DE","DEAL","DEALER","DEALS","DEGREE","DELIVERY","DELL","DELOITTE","DELTA","DEMOCRAT","DENTAL","DENTIST","DESI","DESIGN","DEV","DHL","DIAMONDS","DIET","DIGITAL","DIRECT","DIRECTORY","DISCOUNT","DISCOVER","DISH","DIY","DJ","DK","DM","DNP","DO","DOCS","DOCTOR","DOG","DOMAINS","DOT","DOWNLOAD","DRIVE","DTV","DUBAI","DUNLOP","DUPONT","DURBAN","DVAG","DVR","DZ","EARTH","EAT","EC","ECO","EDEKA","EDU","EDUCATION","EE","EG","EMAIL","EMERCK","ENERGY","ENGINEER","ENGINEERING","ENTERPRISES","EPSON","EQUIPMENT","ER","ERICSSON","ERNI","ES","ESQ","ESTATE","ET","EU","EUROVISION","EUS","EVENTS","EXCHANGE","EXPERT","EXPOSED","EXPRESS","EXTRASPACE","FAGE","FAIL","FAIRWINDS","FAITH","FAMILY","FAN","FANS","FARM","FARMERS","FASHION","FAST","FEDEX","FEEDBACK","FERRARI","FERRERO","FI","FIDELITY","FIDO","FILM","FINAL","FINANCE","FINANCIAL","FIRE","FIRESTONE","FIRMDALE","FISH","FISHING","FIT","FITNESS","FJ","FK","FLICKR","FLIGHTS","FLIR","FLORIST","FLOWERS","FLY","FM","FO","FOO","FOOD","FOOTBALL","FORD","FOREX","FORSALE","FORUM","FOUNDATION","FOX","FR","FREE","FRESENIUS","FRL","FROGANS","FRONTIER","FTR","FUJITSU","FUN","FUND","FURNITURE","FUTBOL","FYI","GA","GAL","GALLERY","GALLO","GALLUP","GAME","GAMES","GAP","GARDEN","GAY","GB","GBIZ","GD","GDN","GE","GEA","GENT","GENTING","GEORGE","GF","GG","GGEE","GH","GI","GIFT","GIFTS","GIVES","GIVING","GL","GLASS","GLE","GLOBAL","GLOBO","GM","GMAIL","GMBH","GMO","GMX","GN","GODADDY","GOLD","GOLDPOINT","GOLF","GOO","GOODYEAR","GOOG","GOOGLE","GOP","GOT","GOV","GP","GQ","GR","GRAINGER","GRAPHICS","GRATIS","GREEN","GRIPE","GROCERY","GROUP","GS","GT","GU","GUCCI","GUGE","GUIDE","GUITARS","GURU","GW","GY","HAIR","HAMBURG","HANGOUT","HAUS","HBO","HDFC","HDFCBANK","HEALTH","HEALTHCARE","HELP","HELSINKI","HERE","HERMES","HIPHOP","HISAMITSU","HITACHI","HIV","HK","HKT","HM","HN","HOCKEY","HOLDINGS","HOLIDAY","HOMEDEPOT","HOMEGOODS","HOMES","HOMESENSE","HONDA","HORSE","HOSPITAL","HOST","HOSTING","HOT","HOTELS","HOTMAIL","HOUSE","HOW","HR","HSBC","HT","HU","HUGHES","HYATT","HYUNDAI","IBM","ICBC","ICE","ICU","ID","IE","IEEE","IFM","IKANO","IL","IM","IMAMAT","IMDB","IMMO","IMMOBILIEN","IN","INC","INDUSTRIES","INFINITI","INFO","ING","INK","INSTITUTE","INSURANCE","INSURE","INT","INTERNATIONAL","INTUIT","INVESTMENTS","IO","IPIRANGA","IQ","IR","IRISH","IS","ISMAILI","IST","ISTANBUL","IT","ITAU","ITV","JAGUAR","JAVA","JCB","JE","JEEP","JETZT","JEWELRY","JIO","JLL","JM","JMP","JNJ","JO","JOBS","JOBURG","JOT","JOY","JP","JPMORGAN","JPRS","JUEGOS","JUNIPER","KAUFEN","KDDI","KE","KERRYHOTELS","KERRYPROPERTIES","KFH","KG","KH","KI","KIA","KIDS","KIM","KINDLE","KITCHEN","KIWI","KM","KN","KOELN","KOMATSU","KOSHER","KP","KPMG","KPN","KR","KRD","KRED","KUOKGROUP","KW","KY","KYOTO","KZ","LA","LACAIXA","LAMBORGHINI","LAMER","LAND","LANDROVER","LANXESS","LASALLE","LAT","LATINO","LATROBE","LAW","LAWYER","LB","LC","LDS","LEASE","LECLERC","LEFRAK","LEGAL","LEGO","LEXUS","LGBT","LI","LIDL","LIFE","LIFEINSURANCE","LIFESTYLE","LIGHTING","LIKE","LILLY","LIMITED","LIMO","LINCOLN","LINK","LIVE","LIVING","LK","LLC","LLP","LOAN","LOANS","LOCKER","LOCUS","LOL","LONDON","LOTTE","LOTTO","LOVE","LPL","LPLFINANCIAL","LR","LS","LT","LTD","LTDA","LU","LUNDBECK","LUXE","LUXURY","LV","LY","MA","MADRID","MAIF","MAISON","MAKEUP","MAN","MANAGEMENT","MANGO","MAP","MARKET","MARKETING","MARKETS","MARRIOTT","MARSHALLS","MATTEL","MBA","MC","MCKINSEY","MD","ME","MED","MEDIA","MEET","MELBOURNE","MEME","MEMORIAL","MEN","MENU","MERCKMSD","MG","MH","MIAMI","MICROSOFT","MIL","MINI","MINT","MIT","MITSUBISHI","MK","ML","MLB","MLS","MM","MMA","MN","MO","MOBI","MOBILE","MODA","MOE","MOI","MOM","MONASH","MONEY","MONSTER","MORMON","MORTGAGE","MOSCOW","MOTO","MOTORCYCLES","MOV","MOVIE","MP","MQ","MR","MS","MSD","MT","MTN","MTR","MU","MUSEUM","MUSIC","MV","MW","MX","MY","MZ","NA","NAB","NAGOYA","NAME","NAVY","NBA","NC","NE","NEC","NET","NETBANK","NETFLIX","NETWORK","NEUSTAR","NEW","NEWS","NEXT","NEXTDIRECT","NEXUS","NF","NFL","NG","NGO","NHK","NI","NICO","NIKE","NIKON","NINJA","NISSAN","NISSAY","NL","NO","NOKIA","NORTON","NOW","NOWRUZ","NOWTV","NP","NR","NRA","NRW","NTT","NU","NYC","NZ","OBI","OBSERVER","OFFICE","OKINAWA","OLAYAN","OLAYANGROUP","OLLO","OM","OMEGA","ONE","ONG","ONL","ONLINE","OOO","OPEN","ORACLE","ORANGE","ORG","ORGANIC","ORIGINS","OSAKA","OTSUKA","OTT","OVH","PA","PAGE","PANASONIC","PARIS","PARS","PARTNERS","PARTS","PARTY","PAY","PCCW","PE","PET","PF","PFIZER","PG","PH","PHARMACY","PHD","PHILIPS","PHONE","PHOTO","PHOTOGRAPHY","PHOTOS","PHYSIO","PICS","PICTET","PICTURES","PID","PIN","PING","PINK","PIONEER","PIZZA","PK","PL","PLACE","PLAY","PLAYSTATION","PLUMBING","PLUS","PM","PN","PNC","POHL","POKER","POLITIE","PORN","POST","PR","PRAXI","PRESS","PRIME","PRO","PROD","PRODUCTIONS","PROF","PROGRESSIVE","PROMO","PROPERTIES","PROPERTY","PROTECTION","PRU","PRUDENTIAL","PS","PT","PUB","PW","PWC","PY","QA","QPON","QUEBEC","QUEST","RACING","RADIO","RE","READ","REALESTATE","REALTOR","REALTY","RECIPES","RED","REDSTONE","REDUMBRELLA","REHAB","REISE","REISEN","REIT","RELIANCE","REN","RENT","RENTALS","REPAIR","REPORT","REPUBLICAN","REST","RESTAURANT","REVIEW","REVIEWS","REXROTH","RICH","RICHARDLI","RICOH","RIL","RIO","RIP","RO","ROCKS","RODEO","ROGERS","ROOM","RS","RSVP","RU","RUGBY","RUHR","RUN","RW","RWE","RYUKYU","SA","SAARLAND","SAFE","SAFETY","SAKURA","SALE","SALON","SAMSCLUB","SAMSUNG","SANDVIK","SANDVIKCOROMANT","SANOFI","SAP","SARL","SAS","SAVE","SAXO","SB","SBI","SBS","SC","SCB","SCHAEFFLER","SCHMIDT","SCHOLARSHIPS","SCHOOL","SCHULE","SCHWARZ","SCIENCE","SCOT","SD","SE","SEARCH","SEAT","SECURE","SECURITY","SEEK","SELECT","SENER","SERVICES","SEVEN","SEW","SEX","SEXY","SFR","SG","SH","SHANGRILA","SHARP","SHELL","SHIA","SHIKSHA","SHOES","SHOP","SHOPPING","SHOUJI","SHOW","SI","SILK","SINA","SINGLES","SITE","SJ","SK","SKI","SKIN","SKY","SKYPE","SL","SLING","SM","SMART","SMILE","SN","SNCF","SO","SOCCER","SOCIAL","SOFTBANK","SOFTWARE","SOHU","SOLAR","SOLUTIONS","SONG","SONY","SOY","SPA","SPACE","SPORT","SPOT","SR","SRL","SS","ST","STADA","STAPLES","STAR","STATEBANK","STATEFARM","STC","STCGROUP","STOCKHOLM","STORAGE","STORE","STREAM","STUDIO","STUDY","STYLE","SU","SUCKS","SUPPLIES","SUPPLY","SUPPORT","SURF","SURGERY","SUZUKI","SV","SWATCH","SWISS","SX","SY","SYDNEY","SYSTEMS","SZ","TAB","TAIPEI","TALK","TAOBAO","TARGET","TATAMOTORS","TATAR","TATTOO","TAX","TAXI","TC","TCI","TD","TDK","TEAM","TECH","TECHNOLOGY","TEL","TEMASEK","TENNIS","TEVA","TF","TG","TH","THD","THEATER","THEATRE","TIAA","TICKETS","TIENDA","TIPS","TIRES","TIROL","TJ","TJMAXX","TJX","TK","TKMAXX","TL","TM","TMALL","TN","TO","TODAY","TOKYO","TOOLS","TOP","TORAY","TOSHIBA","TOTAL","TOURS","TOWN","TOYOTA","TOYS","TR","TRADE","TRADING","TRAINING","TRAVEL","TRAVELERS","TRAVELERSINSURANCE","TRUST","TRV","TT","TUBE","TUI","TUNES","TUSHU","TV","TVS","TW","TZ","UA","UBANK","UBS","UG","UK","UNICOM","UNIVERSITY","UNO","UOL","UPS","US","UY","UZ","VA","VACATIONS","VANA","VANGUARD","VC","VE","VEGAS","VENTURES","VERISIGN","VERSICHERUNG","VET","VG","VI","VIAJES","VIDEO","VIG","VIKING","VILLAS","VIN","VIP","VIRGIN","VISA","VISION","VIVA","VIVO","VLAANDEREN","VN","VODKA","VOLVO","VOTE","VOTING","VOTO","VOYAGE","VU","WALES","WALMART","WALTER","WANG","WANGGOU","WATCH","WATCHES","WEATHER","WEATHERCHANNEL","WEBCAM","WEBER","WEBSITE","WED","WEDDING","WEIBO","WEIR","WF","WHOSWHO","WIEN","WIKI","WILLIAMHILL","WIN","WINDOWS","WINE","WINNERS","WME","WOLTERSKLUWER","WOODSIDE","WORK","WORKS","WORLD","WOW","WS","WTC","WTF","XBOX","XEROX","XIHUAN","XIN","XN--11B4C3D","XN--1CK2E1B","XN--1QQW23A","XN--2SCRJ9C","XN--30RR7Y","XN--3BST00M","XN--3DS443G","XN--3E0B707E","XN--3HCRJ9C","XN--3PXU8K","XN--42C2D9A","XN--45BR5CYL","XN--45BRJ9C","XN--45Q11C","XN--4DBRK0CE","XN--4GBRIM","XN--54B7FTA0CC","XN--55QW42G","XN--55QX5D","XN--5SU34J936BGSG","XN--5TZM5G","XN--6FRZ82G","XN--6QQ986B3XL","XN--80ADXHKS","XN--80AO21A","XN--80AQECDR1A","XN--80ASEHDB","XN--80ASWG","XN--8Y0A063A","XN--90A3AC","XN--90AE","XN--90AIS","XN--9DBQ2A","XN--9ET52U","XN--9KRT00A","XN--B4W605FERD","XN--BCK1B9A5DRE4C","XN--C1AVG","XN--C2BR7G","XN--CCK2B3B","XN--CCKWCXETD","XN--CG4BKI","XN--CLCHC0EA0B2G2A9GCD","XN--CZR694B","XN--CZRS0T","XN--CZRU2D","XN--D1ACJ3B","XN--D1ALF","XN--E1A4C","XN--ECKVDTC9D","XN--EFVY88H","XN--FCT429K","XN--FHBEI","XN--FIQ228C5HS","XN--FIQ64B","XN--FIQS8S","XN--FIQZ9S","XN--FJQ720A","XN--FLW351E","XN--FPCRJ9C3D","XN--FZC2C9E2C","XN--FZYS8D69UVGM","XN--G2XX48C","XN--GCKR3F0F","XN--GECRJ9C","XN--GK3AT1E","XN--H2BREG3EVE","XN--H2BRJ9C","XN--H2BRJ9C8C","XN--HXT814E","XN--I1B6B1A6A2E","XN--IMR513N","XN--IO0A7I","XN--J1AEF","XN--J1AMH","XN--J6W193G","XN--JLQ480N2RG","XN--JVR189M","XN--KCRX77D1X4A","XN--KPRW13D","XN--KPRY57D","XN--KPUT3I","XN--L1ACC","XN--LGBBAT1AD8J","XN--MGB9AWBF","XN--MGBA3A3EJT","XN--MGBA3A4F16A","XN--MGBA7C0BBN0A","XN--MGBAAM7A8H","XN--MGBAB2BD","XN--MGBAH1A3HJKRD","XN--MGBAI9AZGQP6J","XN--MGBAYH7GPA","XN--MGBBH1A","XN--MGBBH1A71E","XN--MGBC0A9AZCG","XN--MGBCA7DZDO","XN--MGBCPQ6GPA1A","XN--MGBERP4A5D4AR","XN--MGBGU82A","XN--MGBI4ECEXP","XN--MGBPL2FH","XN--MGBT3DHD","XN--MGBTX2B","XN--MGBX4CD0AB","XN--MIX891F","XN--MK1BU44C","XN--MXTQ1M","XN--NGBC5AZD","XN--NGBE9E0A","XN--NGBRX","XN--NODE","XN--NQV7F","XN--NQV7FS00EMA","XN--NYQY26A","XN--O3CW4H","XN--OGBPF8FL","XN--OTU796D","XN--P1ACF","XN--P1AI","XN--PGBS0DH","XN--PSSY2U","XN--Q7CE6A","XN--Q9JYB4C","XN--QCKA1PMC","XN--QXA6A","XN--QXAM","XN--RHQV96G","XN--ROVU88B","XN--RVC1E0AM3E","XN--S9BRJ9C","XN--SES554G","XN--T60B56A","XN--TCKWE","XN--TIQ49XQYJ","XN--UNUP4Y","XN--VERMGENSBERATER-CTB","XN--VERMGENSBERATUNG-PWB","XN--VHQUV","XN--VUQ861B","XN--W4R85EL8FHU5DNRA","XN--W4RS40L","XN--WGBH1C","XN--WGBL6A","XN--XHQ521B","XN--XKC2AL3HYE2A","XN--XKC2DL3A5EE0H","XN--Y9A3AQ","XN--YFRO4I67O","XN--YGBI2AMMX","XN--ZFR164B","XXX","XYZ","YACHTS","YAHOO","YAMAXUN","YANDEX","YE","YODOBASHI","YOGA","YOKOHAMA","YOU","YOUTUBE","YT","YUN","ZA","ZAPPOS","ZARA","ZERO","ZIP","ZM","ZONE","ZUERICH","ZW"]},554:()=>{},679:(S,A)=>{const g={operators:["!","^","*","/","%","+","-","<","<=",">",">=","==","!=","&&","||","??"],operatorCharacters:["!","^","*","/","%","+","-","<","=",">","&","|","?"],operatorsOrder:[["^"],["*","/","%"],["+","-"],["<","<=",">",">="],["==","!="],["&&"],["||","??"]],operatorsPrefix:["!","n"],literals:{'"':'"',"`":"`","'":"'","[":"]"},numberRx:/^(?:[0-9]*(\.[0-9]*)?){1}$/,tokenRx:/^[\w\$\#\.\@\:\{\}]+$/,symbol:Symbol("formula"),settings:Symbol("settings")};A.Parser=class{constructor(o,y={}){if(!y[g.settings]&&y.constants)for(const b in y.constants){const p=y.constants[b];if(p!==null&&!["boolean","number","string"].includes(typeof p))throw new Error(`Formula constant ${b} contains invalid ${typeof p} value type`)}this.settings=y[g.settings]?y:Object.assign({[g.settings]:!0,constants:{},functions:{}},y),this.single=null,this._parts=null,this._parse(o)}_parse(o){let y=[],b="",p=0,r=!1;const a=t=>{if(p)throw new Error("Formula missing closing parenthesis");const e=y.length?y[y.length-1]:null;if(r||b||t){if(e&&e.type==="reference"&&t===")")return e.type="function",e.value=this._subFormula(b,e.value),void(b="");if(t===")"){const l=new A.Parser(b,this.settings);y.push({type:"segment",value:l})}else if(r){if(r==="]")return y.push({type:"reference",value:b}),void(b="");y.push({type:"literal",value:b})}else if(g.operatorCharacters.includes(b))e&&e.type==="operator"&&g.operators.includes(e.value+b)?e.value+=b:y.push({type:"operator",value:b});else if(b.match(g.numberRx))y.push({type:"constant",value:parseFloat(b)});else if(this.settings.constants[b]!==void 0)y.push({type:"constant",value:this.settings.constants[b]});else{if(!b.match(g.tokenRx))throw new Error(`Formula contains invalid token: ${b}`);y.push({type:"reference",value:b})}b=""}};for(const t of o)r?t===r?(a(),r=!1):b+=t:p?t==="("?(b+=t,++p):t===")"?(--p,p?b+=t:a(t)):b+=t:t in g.literals?r=g.literals[t]:t==="("?(a(),++p):g.operatorCharacters.includes(t)?(a(),b=t,a()):t!==" "?b+=t:a();a(),y=y.map((t,e)=>t.type!=="operator"||t.value!=="-"||e&&y[e-1].type!=="operator"?t:{type:"operator",value:"n"});let n=!1;for(const t of y){if(t.type==="operator"){if(g.operatorsPrefix.includes(t.value))continue;if(!n)throw new Error("Formula contains an operator in invalid position");if(!g.operators.includes(t.value))throw new Error(`Formula contains an unknown operator ${t.value}`)}else if(n)throw new Error("Formula missing expected operator");n=!n}if(!n)throw new Error("Formula contains invalid trailing operator");y.length===1&&["reference","literal","constant"].includes(y[0].type)&&(this.single={type:y[0].type==="reference"?"reference":"value",value:y[0].value}),this._parts=y.map(t=>{if(t.type==="operator")return g.operatorsPrefix.includes(t.value)?t:t.value;if(t.type!=="reference")return t.value;if(this.settings.tokenRx&&!this.settings.tokenRx.test(t.value))throw new Error(`Formula contains invalid reference ${t.value}`);return this.settings.reference?this.settings.reference(t.value):g.reference(t.value)})}_subFormula(o,y){const b=this.settings.functions[y];if(typeof b!="function")throw new Error(`Formula contains unknown function ${y}`);let p=[];if(o){let r="",a=0,n=!1;const t=()=>{if(!r)throw new Error(`Formula contains function ${y} with invalid arguments ${o}`);p.push(r),r=""};for(let e=0;e<o.length;++e){const l=o[e];n?(r+=l,l===n&&(n=!1)):l in g.literals&&!a?(r+=l,n=g.literals[l]):l!==","||a?(r+=l,l==="("?++a:l===")"&&--a):t()}t()}return p=p.map(r=>new A.Parser(r,this.settings)),function(r){const a=[];for(const n of p)a.push(n.evaluate(r));return b.call(r,...a)}}evaluate(o){const y=this._parts.slice();for(let b=y.length-2;b>=0;--b){const p=y[b];if(p&&p.type==="operator"){const r=y[b+1];y.splice(b+1,1);const a=g.evaluate(r,o);y[b]=g.single(p.value,a)}}return g.operatorsOrder.forEach(b=>{for(let p=1;p<y.length-1;)if(b.includes(y[p])){const r=y[p],a=g.evaluate(y[p-1],o),n=g.evaluate(y[p+1],o);y.splice(p,2);const t=g.calculate(r,a,n);y[p-1]=t===0?0:t}else p+=2}),g.evaluate(y[0],o)}},A.Parser.prototype[g.symbol]=!0,g.reference=function(o){return function(y){return y&&y[o]!==void 0?y[o]:null}},g.evaluate=function(o,y){return o===null?null:typeof o=="function"?o(y):o[g.symbol]?o.evaluate(y):o},g.single=function(o,y){if(o==="!")return!y;const b=-y;return b===0?0:b},g.calculate=function(o,y,b){if(o==="??")return g.exists(y)?y:b;if(typeof y=="string"||typeof b=="string"){if(o==="+")return(y=g.exists(y)?y:"")+(g.exists(b)?b:"")}else switch(o){case"^":return Math.pow(y,b);case"*":return y*b;case"/":return y/b;case"%":return y%b;case"+":return y+b;case"-":return y-b}switch(o){case"<":return y<b;case"<=":return y<=b;case">":return y>b;case">=":return y>=b;case"==":return y===b;case"!=":return y!==b;case"&&":return y&&b;case"||":return y||b}return null},g.exists=function(o){return o!=null}},680:(S,A,g)=>{const{assert:o}=g(3115),y=g(2115),b=g(9415),p=g(6162);S.exports=y.extend({type:"any",flags:{only:{default:!1}},terms:{alterations:{init:null},examples:{init:null},externals:{init:null},metas:{init:[]},notes:{init:[]},shared:{init:null},tags:{init:[]},whens:{init:null}},rules:{custom:{method(r,a){return o(typeof r=="function","Method must be a function"),o(a===void 0||a&&typeof a=="string","Description must be a non-empty string"),this.$_addRule({name:"custom",args:{method:r,description:a}})},validate(r,a,{method:n}){try{return n(r,a)}catch(t){return a.error("any.custom",{error:t})}},args:["method","description"],multi:!0},messages:{method(r){return this.prefs({messages:r})}},shared:{method(r){o(b.isSchema(r)&&r._flags.id,"Schema must be a schema with an id");const a=this.clone();return a.$_terms.shared=a.$_terms.shared||[],a.$_terms.shared.push(r),a.$_mutateRegister(r),a}},warning:{method(r,a){return o(r&&typeof r=="string","Invalid warning code"),this.$_addRule({name:"warning",args:{code:r,local:a},warn:!0})},validate:(r,a,{code:n,local:t})=>a.error(n,t),args:["code","local"],multi:!0}},modifiers:{keep(r,a=!0){r.keep=a},message(r,a){r.message=p.compile(a)},warn(r,a=!0){r.warn=a}},manifest:{build(r,a){for(const n in a){const t=a[n];if(["examples","externals","metas","notes","tags"].includes(n))for(const e of t)r=r[n.slice(0,-1)](e);else{if(n==="alterations"){const e={};for(const{target:l,adjuster:s}of t)e[l]=s;r=r.alter(e);continue}if(n!=="whens"){if(n==="shared")for(const e of t)r=r.shared(e)}else for(const e of t){const{ref:l,is:s,not:i,then:u,otherwise:f,concat:h}=e;r=h?r.concat(h):l?r.when(l,{is:s,not:i,then:u,otherwise:f,switch:e.switch,break:e.break}):r.when(s,{then:u,otherwise:f,break:e.break})}}}return r}},messages:{"any.custom":"{{#label}} failed custom validation because {{#error.message}}","any.default":"{{#label}} threw an error when running default method","any.failover":"{{#label}} threw an error when running failover method","any.invalid":"{{#label}} contains an invalid value","any.only":'{{#label}} must be {if(#valids.length == 1, "", "one of ")}{{#valids}}',"any.ref":"{{#label}} {{#arg}} references {{:#ref}} which {{#reason}}","any.required":"{{#label}} is required","any.unknown":"{{#label}} is not allowed"}})},834:S=>{S.exports=function(A){return typeof(A==null?void 0:A.then)=="function"}},1100:(S,A,g)=>{const{assert:o,clone:y}=g(3115),b=g(2130),p=g(9415),r=g(3541),a=g(8013),n=g(2062),t=g(9017),e=g(8529),l=g(1532),s=g(125);let i;const u={types:{alternatives:g(4972),any:g(680),array:g(2591),boolean:g(6186),date:g(2588),function:g(4840),link:g(9556),number:g(4709),object:g(7487),string:g(9033),symbol:g(5008)},aliases:{alt:"alternatives",bool:"boolean",func:"function"},root:function(){const f={_types:new Set(Object.keys(u.types))};for(const h of f._types)f[h]=function(...v){return o(!v.length||["alternatives","link","object"].includes(h),"The",h,"type does not allow arguments"),u.generate(this,u.types[h],v)};for(const h of["allow","custom","disallow","equal","exist","forbidden","invalid","not","only","optional","options","prefs","preferences","required","strip","valid","when"])f[h]=function(...v){return this.any()[h](...v)};Object.assign(f,u.methods);for(const h in u.aliases){const v=u.aliases[h];f[h]=f[v]}return f.x=f.expression,s.setup&&s.setup(f),f}};u.methods={ValidationError:a.ValidationError,version:p.version,cache:b.provider,assert(f,h,...v){u.assert(f,h,!0,v)},attempt:(f,h,...v)=>u.assert(f,h,!1,v),build(f){return o(typeof t.build=="function","Manifest functionality disabled"),t.build(this,f)},checkPreferences(f){p.checkPreferences(f)},compile(f,h){return r.compile(this,f,h)},defaults(f){o(typeof f=="function","modifier must be a function");const h=Object.assign({},this);for(const v of h._types){const _=f(h[v]());o(p.isSchema(_),"modifier must return a valid schema object"),h[v]=function(...c){return u.generate(this,_,c)}}return h},expression:(...f)=>new l(...f),extend(...f){p.verifyFlat(f,"extend"),i=i||g(1688),o(f.length,"You need to provide at least one extension"),this.assert(f,i.extensions);const h=Object.assign({},this);h._types=new Set(h._types);for(let v of f){typeof v=="function"&&(v=v(h)),this.assert(v,i.extension);const _=u.expandExtension(v,h);for(const c of _){o(h[c.type]===void 0||h._types.has(c.type),"Cannot override name",c.type);const m=c.base||this.any(),d=n.type(m,c);h._types.add(c.type),h[c.type]=function(...E){return u.generate(this,d,E)}}}return h},isError:a.ValidationError.isError,isExpression:l.isTemplate,isRef:e.isRef,isSchema:p.isSchema,in:(...f)=>e.in(...f),override:p.symbols.override,ref:(...f)=>e.create(...f),types(){const f={};for(const h of this._types)f[h]=this[h]();for(const h in u.aliases)f[h]=this[h]();return f}},u.assert=function(f,h,v,_){const c=_[0]instanceof Error||typeof _[0]=="string"?_[0]:null,m=c!==null?_[1]:_[0],d=h.validate(f,p.preferences({errors:{stack:!0}},m||{}));let E=d.error;if(!E)return d.value;if(c instanceof Error)throw c;const R=v&&typeof E.annotate=="function"?E.annotate():E.message;throw E instanceof a.ValidationError==0&&(E=y(E)),E.message=c?`${c} ${R}`:R,E},u.generate=function(f,h,v){return o(f,"Must be invoked on a Joi instance."),h.$_root=f,h._definition.args&&v.length?h._definition.args(h,...v):h},u.expandExtension=function(f,h){if(typeof f.type=="string")return[f];const v=[];for(const _ of h._types)if(f.type.test(_)){const c=Object.assign({},f);c.type=_,c.base=h[_](),v.push(c)}return v},S.exports=u.root()},1190:(S,A,g)=>{const{assert:o,clone:y,ignore:b,reach:p}=g(3115),r=g(9415),a=g(8013),n=g(4957),t={result:Symbol("result")};A.entry=function(e,l,s){let i=r.defaults;s&&(o(s.warnings===void 0,"Cannot override warnings preference in synchronous validation"),o(s.artifacts===void 0,"Cannot override artifacts preference in synchronous validation"),i=r.preferences(r.defaults,s));const u=t.entry(e,l,i);o(!u.mainstay.externals.length,"Schema with external rules must use validateAsync()");const f={value:u.value};return u.error&&(f.error=u.error),u.mainstay.warnings.length&&(f.warning=a.details(u.mainstay.warnings)),u.mainstay.debug&&(f.debug=u.mainstay.debug),u.mainstay.artifacts&&(f.artifacts=u.mainstay.artifacts),f},A.entryAsync=async function(e,l,s){let i=r.defaults;s&&(i=r.preferences(r.defaults,s));const u=t.entry(e,l,i),f=u.mainstay;if(u.error)throw f.debug&&(u.error.debug=f.debug),u.error;if(f.externals.length){let v=u.value;const _=[];for(const c of f.externals){const m=c.state.path,d=c.schema.type==="link"?f.links.get(c.schema):null;let E,R,w=v;const N=m.length?[v]:[],I=m.length?p(e,m):e;if(m.length){E=m[m.length-1];let T=v;for(const D of m.slice(0,-1))T=T[D],N.unshift(T);R=N[0],w=R[E]}try{const T=(B,F)=>(d||c.schema).$_createError(B,w,F,c.state,i),D=await c.method(w,{schema:c.schema,linked:d,state:c.state,prefs:s,original:I,error:T,errorsArray:t.errorsArray,warn:(B,F)=>f.warnings.push((d||c.schema).$_createError(B,w,F,c.state,i)),message:(B,F)=>(d||c.schema).$_createError("external",w,F,c.state,i,{messages:B})});if(D===void 0||D===w)continue;if(D instanceof a.Report){if(f.tracer.log(c.schema,c.state,"rule","external","error"),_.push(D),i.abortEarly)break;continue}if(Array.isArray(D)&&D[r.symbols.errors]){if(f.tracer.log(c.schema,c.state,"rule","external","error"),_.push(...D),i.abortEarly)break;continue}R?(f.tracer.value(c.state,"rule",w,D,"external"),R[E]=D):(f.tracer.value(c.state,"rule",v,D,"external"),v=D)}catch(T){throw i.errors.label&&(T.message+=` (${c.label})`),T}}if(u.value=v,_.length)throw u.error=a.process(_,e,i),f.debug&&(u.error.debug=f.debug),u.error}if(!i.warnings&&!i.debug&&!i.artifacts)return u.value;const h={value:u.value};return f.warnings.length&&(h.warning=a.details(f.warnings)),f.debug&&(h.debug=f.debug),f.artifacts&&(h.artifacts=f.artifacts),h},A.standard=function(e,l){return l.isAsync()?A.entryAsync(e,l):A.entry(e,l)},t.Mainstay=class{constructor(e,l,s){this.externals=[],this.warnings=[],this.tracer=e,this.debug=l,this.links=s,this.shadow=null,this.artifacts=null,this._snapshots=[]}snapshot(){this._snapshots.push({externals:this.externals.slice(),warnings:this.warnings.slice()})}restore(){const e=this._snapshots.pop();this.externals=e.externals,this.warnings=e.warnings}commit(){this._snapshots.pop()}},t.entry=function(e,l,s){const{tracer:i,cleanup:u}=t.tracer(l,s),f=s.debug?[]:null,h=l._ids._schemaChain?new Map:null,v=new t.Mainstay(i,f,h),_=l._ids._schemaChain?[{schema:l}]:null,c=new n([],[],{mainstay:v,schemas:_}),m=A.validate(e,l,c,s);u&&l.$_root.untrace();const d=a.process(m.errors,e,s);return{value:m.value,error:d,mainstay:v}},t.tracer=function(e,l){return e.$_root._tracer?{tracer:e.$_root._tracer._register(e)}:l.debug?(o(e.$_root.trace,"Debug mode not supported"),{tracer:e.$_root.trace()._register(e),cleanup:!0}):{tracer:t.ignore}},A.validate=function(e,l,s,i,u={}){if(l.$_terms.whens&&(l=l._generate(e,s,i).schema),l._preferences&&(i=t.prefs(l,i)),l._cache&&i.cache){const d=l._cache.get(e);if(s.mainstay.tracer.debug(s,"validate","cached",!!d),d)return d}const f=(d,E,R)=>l.$_createError(d,e,E,R||s,i),h={original:e,prefs:i,schema:l,state:s,error:f,errorsArray:t.errorsArray,warn:(d,E,R)=>s.mainstay.warnings.push(f(d,E,R)),message:(d,E)=>l.$_createError("custom",e,E,s,i,{messages:d})};s.mainstay.tracer.entry(l,s);const v=l._definition;if(v.prepare&&e!==void 0&&i.convert){const d=v.prepare(e,h);if(d){if(s.mainstay.tracer.value(s,"prepare",e,d.value),d.errors)return t.finalize(d.value,[].concat(d.errors),h);e=d.value}}if(v.coerce&&e!==void 0&&i.convert&&(!v.coerce.from||v.coerce.from.includes(typeof e))){const d=v.coerce.method(e,h);if(d){if(s.mainstay.tracer.value(s,"coerced",e,d.value),d.errors)return t.finalize(d.value,[].concat(d.errors),h);e=d.value}}const _=l._flags.empty;_&&_.$_match(t.trim(e,l),s.nest(_),r.defaults)&&(s.mainstay.tracer.value(s,"empty",e,void 0),e=void 0);const c=u.presence||l._flags.presence||(l._flags._endedSwitch?null:i.presence);if(e===void 0){if(c==="forbidden")return t.finalize(e,null,h);if(c==="required")return t.finalize(e,[l.$_createError("any.required",e,null,s,i)],h);if(c==="optional"){if(l._flags.default!==r.symbols.deepDefault)return t.finalize(e,null,h);s.mainstay.tracer.value(s,"default",e,{}),e={}}}else if(c==="forbidden")return t.finalize(e,[l.$_createError("any.unknown",e,null,s,i)],h);const m=[];if(l._valids){const d=l._valids.get(e,s,i,l._flags.insensitive);if(d)return i.convert&&(s.mainstay.tracer.value(s,"valids",e,d.value),e=d.value),s.mainstay.tracer.filter(l,s,"valid",d),t.finalize(e,null,h);if(l._flags.only){const E=l.$_createError("any.only",e,{valids:l._valids.values({display:!0})},s,i);if(i.abortEarly)return t.finalize(e,[E],h);m.push(E)}}if(l._invalids){const d=l._invalids.get(e,s,i,l._flags.insensitive);if(d){s.mainstay.tracer.filter(l,s,"invalid",d);const E=l.$_createError("any.invalid",e,{invalids:l._invalids.values({display:!0})},s,i);if(i.abortEarly)return t.finalize(e,[E],h);m.push(E)}}if(v.validate){const d=v.validate(e,h);if(d&&(s.mainstay.tracer.value(s,"base",e,d.value),e=d.value,d.errors)){if(!Array.isArray(d.errors))return m.push(d.errors),t.finalize(e,m,h);if(d.errors.length)return m.push(...d.errors),t.finalize(e,m,h)}}return l._rules.length?t.rules(e,m,h):t.finalize(e,m,h)},t.rules=function(e,l,s){const{schema:i,state:u,prefs:f}=s;for(const h of i._rules){const v=i._definition.rules[h.method];if(v.convert&&f.convert){u.mainstay.tracer.log(i,u,"rule",h.name,"full");continue}let _,c=h.args;if(h._resolve.length){c=Object.assign({},c);for(const d of h._resolve){const E=v.argsByName.get(d),R=c[d].resolve(e,u,f),w=E.normalize?E.normalize(R):R,N=r.validateArg(w,null,E);if(N){_=i.$_createError("any.ref",R,{arg:d,ref:c[d],reason:N},u,f);break}c[d]=w}}_=_||v.validate(e,s,c,h);const m=t.rule(_,h);if(m.errors){if(u.mainstay.tracer.log(i,u,"rule",h.name,"error"),h.warn){u.mainstay.warnings.push(...m.errors);continue}if(f.abortEarly)return t.finalize(e,m.errors,s);l.push(...m.errors)}else u.mainstay.tracer.log(i,u,"rule",h.name,"pass"),u.mainstay.tracer.value(u,"rule",e,m.value,h.name),e=m.value}return t.finalize(e,l,s)},t.rule=function(e,l){return e instanceof a.Report?(t.error(e,l),{errors:[e],value:null}):Array.isArray(e)&&e[r.symbols.errors]?(e.forEach(s=>t.error(s,l)),{errors:e,value:null}):{errors:null,value:e}},t.error=function(e,l){return l.message&&e._setTemplate(l.message),e},t.finalize=function(e,l,s){l=l||[];const{schema:i,state:u,prefs:f}=s;if(l.length){const v=t.default("failover",void 0,l,s);v!==void 0&&(u.mainstay.tracer.value(u,"failover",e,v),e=v,l=[])}if(l.length&&i._flags.error)if(typeof i._flags.error=="function"){l=i._flags.error(l),Array.isArray(l)||(l=[l]);for(const v of l)o(v instanceof Error||v instanceof a.Report,"error() must return an Error object")}else l=[i._flags.error];if(e===void 0){const v=t.default("default",e,l,s);u.mainstay.tracer.value(u,"default",e,v),e=v}if(i._flags.cast&&e!==void 0){const v=i._definition.cast[i._flags.cast];if(v.from(e)){const _=v.to(e,s);u.mainstay.tracer.value(u,"cast",e,_,i._flags.cast),e=_}}if(i.$_terms.externals&&f.externals&&f._externals!==!1)for(const{method:v}of i.$_terms.externals)u.mainstay.externals.push({method:v,schema:i,state:u,label:a.label(i._flags,u,f)});const h={value:e,errors:l.length?l:null};return i._flags.result&&(h.value=i._flags.result==="strip"?void 0:s.original,u.mainstay.tracer.value(u,i._flags.result,e,h.value),u.shadow(e,i._flags.result)),i._cache&&f.cache!==!1&&!i._refs.length&&i._cache.set(s.original,h),e===void 0||h.errors||i._flags.artifact===void 0||(u.mainstay.artifacts=u.mainstay.artifacts||new Map,u.mainstay.artifacts.has(i._flags.artifact)||u.mainstay.artifacts.set(i._flags.artifact,[]),u.mainstay.artifacts.get(i._flags.artifact).push(u.path)),h},t.prefs=function(e,l){const s=l===r.defaults;return s&&e._preferences[r.symbols.prefs]?e._preferences[r.symbols.prefs]:(l=r.preferences(l,e._preferences),s&&(e._preferences[r.symbols.prefs]=l),l)},t.default=function(e,l,s,i){const{schema:u,state:f,prefs:h}=i,v=u._flags[e];if(h.noDefaults||v===void 0)return l;if(f.mainstay.tracer.log(u,f,"rule",e,"full"),!v)return v;if(typeof v=="function"){const _=v.length?[y(f.ancestors[0]),i]:[];try{return v(..._)}catch(c){return void s.push(u.$_createError(`any.${e}`,null,{error:c},f,h))}}return typeof v!="object"?v:v[r.symbols.literal]?v.literal:r.isResolvable(v)?v.resolve(l,f,h):y(v)},t.trim=function(e,l){if(typeof e!="string")return e;const s=l.$_getRule("trim");return s&&s.args.enabled?e.trim():e},t.ignore={active:!1,debug:b,entry:b,filter:b,log:b,resolve:b,value:b},t.errorsArray=function(){const e=[];return e[r.symbols.errors]=!0,e}},1528:(S,A,g)=>{const o=g(8253),y={};S.exports=function(b,p,r){if(p===!1||p==null)return b;typeof(r=r||{})=="string"&&(r={separator:r});const a=Array.isArray(p);o(!a||!r.separator,"Separator option is not valid for array-based chain");const n=a?p:p.split(r.separator||".");let t=b;for(let e=0;e<n.length;++e){let l=n[e];const s=r.iterables&&y.iterables(t);if(Array.isArray(t)||s==="set"){const i=Number(l);Number.isInteger(i)&&(l=i<0?t.length+i:i)}if(!t||typeof t=="function"&&r.functions===!1||!s&&t[l]===void 0){o(!r.strict||e+1===n.length,"Missing segment",l,"in reach path ",p),o(typeof t=="object"||r.functions===!0||typeof t!="function","Invalid segment",l,"in reach path ",p),t=r.default;break}t=s?s==="set"?[...t][l]:t.get(l):t[l]}return t},y.iterables=function(b){return b instanceof Set?"set":b instanceof Map?"map":void 0}},1532:(S,A,g)=>{const{assert:o,clone:y,escapeHtml:b}=g(3115),p=g(679),r=g(9415),a=g(8013),n=g(8529),t={symbol:Symbol("template"),opens:new Array(1e3).join("\0"),closes:new Array(1e3).join(""),dateFormat:{date:Date.prototype.toDateString,iso:Date.prototype.toISOString,string:Date.prototype.toString,time:Date.prototype.toTimeString,utc:Date.prototype.toUTCString}};S.exports=t.Template=class{constructor(e,l){if(o(typeof e=="string","Template source must be a string"),o(!e.includes("\0")&&!e.includes(""),"Template source cannot contain reserved control characters"),this.source=e,this.rendered=e,this._template=null,l){const{functions:s,...i}=l;this._settings=Object.keys(i).length?y(i):void 0,this._functions=s,this._functions&&(o(Object.keys(this._functions).every(u=>typeof u=="string"),"Functions keys must be strings"),o(Object.values(this._functions).every(u=>typeof u=="function"),"Functions values must be functions"))}else this._settings=void 0,this._functions=void 0;this._parse()}_parse(){if(!this.source.includes("{"))return;const e=t.encode(this.source),l=t.split(e);let s=!1;const i=[],u=l.shift();u&&i.push(u);for(const f of l){const h=f[0]!=="{",v=h?"}":"}}",_=f.indexOf(v);if(_===-1||f[1]==="{"){i.push(`{${t.decode(f)}`);continue}let c=f.slice(h?0:1,_);const m=c[0]===":";m&&(c=c.slice(1));const d=this._ref(t.decode(c),{raw:h,wrapped:m});i.push(d),typeof d!="string"&&(s=!0);const E=f.slice(_+v.length);E&&i.push(t.decode(E))}s?this._template=i:this.rendered=i.join("")}static date(e,l){return t.dateFormat[l.dateFormat].call(e)}describe(e={}){if(!this._settings&&e.compact)return this.source;const l={template:this.source};return this._settings&&(l.options=this._settings),this._functions&&(l.functions=this._functions),l}static build(e){return new t.Template(e.template,e.options||e.functions?{...e.options,functions:e.functions}:void 0)}isDynamic(){return!!this._template}static isTemplate(e){return!!e&&!!e[r.symbols.template]}refs(){if(!this._template)return;const e=[];for(const l of this._template)typeof l!="string"&&e.push(...l.refs);return e}resolve(e,l,s,i){return this._template&&this._template.length===1?this._part(this._template[0],e,l,s,i,{}):this.render(e,l,s,i)}_part(e,...l){return e.ref?e.ref.resolve(...l):e.formula.evaluate(l)}render(e,l,s,i,u={}){if(!this.isDynamic())return this.rendered;const f=[];for(const h of this._template)if(typeof h=="string")f.push(h);else{const v=this._part(h,e,l,s,i,u),_=t.stringify(v,e,l,s,i,u);if(_!==void 0){const c=h.raw||(u.errors&&u.errors.escapeHtml)===!1?_:b(_);f.push(t.wrap(c,h.wrapped&&s.errors.wrap.label))}}return f.join("")}_ref(e,{raw:l,wrapped:s}){const i=[],u=h=>{const v=n.create(h,this._settings);return i.push(v),_=>{const c=v.resolve(..._);return c!==void 0?c:null}};try{const h=this._functions?{...t.functions,...this._functions}:t.functions;var f=new p.Parser(e,{reference:u,functions:h,constants:t.constants})}catch(h){throw h.message=`Invalid template variable "${e}" fails due to: ${h.message}`,h}if(f.single){if(f.single.type==="reference"){const h=i[0];return{ref:h,raw:l,refs:i,wrapped:s||h.type==="local"&&h.key==="label"}}return t.stringify(f.single.value)}return{formula:f,raw:l,refs:i}}toString(){return this.source}},t.Template.prototype[r.symbols.template]=!0,t.Template.prototype.isImmutable=!0,t.encode=function(e){return e.replace(/\\(\{+)/g,(l,s)=>t.opens.slice(0,s.length)).replace(/\\(\}+)/g,(l,s)=>t.closes.slice(0,s.length))},t.decode=function(e){return e.replace(/\u0000/g,"{").replace(/\u0001/g,"}")},t.split=function(e){const l=[];let s="";for(let i=0;i<e.length;++i){const u=e[i];if(u==="{"){let f="";for(;i+1<e.length&&e[i+1]==="{";)f+="{",++i;l.push(s),s=f}else s+=u}return l.push(s),l},t.wrap=function(e,l){return l?l.length===1?`${l}${e}${l}`:`${l[0]}${e}${l[1]}`:e},t.stringify=function(e,l,s,i,u,f={}){const h=typeof e,v=i&&i.errors&&i.errors.wrap||{};let _=!1;if(n.isRef(e)&&e.render&&(_=e.in,e=e.resolve(l,s,i,u,{in:e.in,...f})),e===null)return"null";if(h==="string")return t.wrap(e,f.arrayItems&&v.string);if(h==="number"||h==="function"||h==="symbol")return e.toString();if(h!=="object")return JSON.stringify(e);if(e instanceof Date)return t.Template.date(e,i);if(e instanceof Map){const m=[];for(const[d,E]of e.entries())m.push(`${d.toString()} -> ${E.toString()}`);e=m}if(!Array.isArray(e))return e.toString();const c=[];for(const m of e)c.push(t.stringify(m,l,s,i,u,{arrayItems:!0,...f}));return t.wrap(c.join(", "),!_&&v.array)},t.constants={true:!0,false:!1,null:null,second:1e3,minute:6e4,hour:36e5,day:864e5},t.functions={if:(e,l,s)=>e?l:s,length:e=>typeof e=="string"?e.length:e&&typeof e=="object"?Array.isArray(e)?e.length:Object.keys(e).length:null,msg(e){const[l,s,i,u,f]=this,h=f.messages;if(!h)return"";const v=a.template(l,h[0],e,s,i)||a.template(l,h[1],e,s,i);return v?v.render(l,s,i,u,f):""},number:e=>typeof e=="number"?e:typeof e=="string"?parseFloat(e):typeof e=="boolean"?e?1:0:e instanceof Date?e.getTime():null}},1626:(S,A,g)=>{const o=g(1528);S.exports=function(y,b,p){return b.replace(/{([^{}]+)}/g,(r,a)=>{const n=o(y,a,p);return n??""})}},1688:(S,A,g)=>{const o=g(1100),y={};y.wrap=o.string().min(1).max(2).allow(!1),A.preferences=o.object({allowUnknown:o.boolean(),abortEarly:o.boolean(),artifacts:o.boolean(),cache:o.boolean(),context:o.object(),convert:o.boolean(),dateFormat:o.valid("date","iso","string","time","utc"),debug:o.boolean(),errors:{escapeHtml:o.boolean(),label:o.valid("path","key",!1),language:[o.string(),o.object().ref()],render:o.boolean(),stack:o.boolean(),wrap:{label:y.wrap,array:y.wrap,string:y.wrap}},externals:o.boolean(),messages:o.object(),noDefaults:o.boolean(),nonEnumerables:o.boolean(),presence:o.valid("required","optional","forbidden"),skipFunctions:o.boolean(),stripUnknown:o.object({arrays:o.boolean(),objects:o.boolean()}).or("arrays","objects").allow(!0,!1),warnings:o.boolean()}).strict(),y.nameRx=/^[a-zA-Z0-9]\w*$/,y.rule=o.object({alias:o.array().items(o.string().pattern(y.nameRx)).single(),args:o.array().items(o.string(),o.object({name:o.string().pattern(y.nameRx).required(),ref:o.boolean(),assert:o.alternatives([o.function(),o.object().schema()]).conditional("ref",{is:!0,then:o.required()}),normalize:o.function(),message:o.string().when("assert",{is:o.function(),then:o.required()})})),convert:o.boolean(),manifest:o.boolean(),method:o.function().allow(!1),multi:o.boolean(),validate:o.function()}),A.extension=o.object({type:o.alternatives([o.string(),o.object().regex()]).required(),args:o.function(),cast:o.object().pattern(y.nameRx,o.object({from:o.function().maxArity(1).required(),to:o.function().minArity(1).maxArity(2).required()})),base:o.object().schema().when("type",{is:o.object().regex(),then:o.forbidden()}),coerce:[o.function().maxArity(3),o.object({method:o.function().maxArity(3).required(),from:o.array().items(o.string()).single()})],flags:o.object().pattern(y.nameRx,o.object({setter:o.string(),default:o.any()})),manifest:{build:o.function().arity(2)},messages:[o.object(),o.string()],modifiers:o.object().pattern(y.nameRx,o.function().minArity(1).maxArity(2)),overrides:o.object().pattern(y.nameRx,o.function()),prepare:o.function().maxArity(3),rebuild:o.function().arity(1),rules:o.object().pattern(y.nameRx,y.rule),terms:o.object().pattern(y.nameRx,o.object({init:o.array().allow(null).required(),manifest:o.object().pattern(/.+/,[o.valid("schema","single"),o.object({mapped:o.object({from:o.string().required(),to:o.string().required()}).required()})])})),validate:o.function().maxArity(3)}).strict(),A.extensions=o.array().items(o.object(),o.function().arity(1)).strict(),y.desc={buffer:o.object({buffer:o.string()}),func:o.object({function:o.function().required(),options:{literal:!0}}),override:o.object({override:!0}),ref:o.object({ref:o.object({type:o.valid("value","global","local"),path:o.array().required(),separator:o.string().length(1).allow(!1),ancestor:o.number().min(0).integer().allow("root"),map:o.array().items(o.array().length(2)).min(1),adjust:o.function(),iterables:o.boolean(),in:o.boolean(),render:o.boolean()}).required()}),regex:o.object({regex:o.string().min(3)}),special:o.object({special:o.valid("deep").required()}),template:o.object({template:o.string().required(),options:o.object()}),value:o.object({value:o.alternatives([o.object(),o.array()]).required()})},y.desc.entity=o.alternatives([o.array().items(o.link("...")),o.boolean(),o.function(),o.number(),o.string(),y.desc.buffer,y.desc.func,y.desc.ref,y.desc.regex,y.desc.special,y.desc.template,y.desc.value,o.link("/")]),y.desc.values=o.array().items(null,o.boolean(),o.function(),o.number().allow(1/0,-1/0),o.string().allow(""),o.symbol(),y.desc.buffer,y.desc.func,y.desc.override,y.desc.ref,y.desc.regex,y.desc.template,y.desc.value),y.desc.messages=o.object().pattern(/.+/,[o.string(),y.desc.template,o.object().pattern(/.+/,[o.string(),y.desc.template])]),A.description=o.object({type:o.string().required(),flags:o.object({cast:o.string(),default:o.any(),description:o.string(),empty:o.link("/"),failover:y.desc.entity,id:o.string(),label:o.string(),only:!0,presence:["optional","required","forbidden"],result:["raw","strip"],strip:o.boolean(),unit:o.string()}).unknown(),preferences:{allowUnknown:o.boolean(),abortEarly:o.boolean(),artifacts:o.boolean(),cache:o.boolean(),convert:o.boolean(),dateFormat:["date","iso","string","time","utc"],errors:{escapeHtml:o.boolean(),label:["path","key"],language:[o.string(),y.desc.ref],wrap:{label:y.wrap,array:y.wrap}},externals:o.boolean(),messages:y.desc.messages,noDefaults:o.boolean(),nonEnumerables:o.boolean(),presence:["required","optional","forbidden"],skipFunctions:o.boolean(),stripUnknown:o.object({arrays:o.boolean(),objects:o.boolean()}).or("arrays","objects").allow(!0,!1),warnings:o.boolean()},allow:y.desc.values,invalid:y.desc.values,rules:o.array().min(1).items({name:o.string().required(),args:o.object().min(1),keep:o.boolean(),message:[o.string(),y.desc.messages],warn:o.boolean()}),keys:o.object().pattern(/.*/,o.link("/")),link:y.desc.ref}).pattern(/^[a-z]\w*$/,o.any())},1803:S=>{S.exports=class extends Error{constructor(A,g){var o,y,b;super(A||"Unknown error"),o=this,b="AssertError",(y=(function(p){var r=(function(a){if(typeof a!="object"||!a)return a;var n=a[Symbol.toPrimitive];if(n!==void 0){var t=n.call(a,"string");if(typeof t!="object")return t;throw new TypeError("@@toPrimitive must return a primitive value.")}return String(a)})(p);return typeof r=="symbol"?r:r+""})(y="name"))in o?Object.defineProperty(o,y,{value:b,enumerable:!0,configurable:!0,writable:!0}):o[y]=b,typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,g)}}},2062:(S,A,g)=>{const{assert:o,clone:y}=g(3115),b=g(9415),p=g(6162),r={};A.type=function(a,n){const t=Object.getPrototypeOf(a),e=y(t),l=a._assign(Object.create(e)),s=Object.assign({},n);delete s.base,e._definition=s;const i=t._definition||{};s.messages=p.merge(i.messages,s.messages),s.properties=Object.assign({},i.properties,s.properties),l.type=s.type,s.flags=Object.assign({},i.flags,s.flags);const u=Object.assign({},i.terms);if(s.terms)for(const _ in s.terms){const c=s.terms[_];o(l.$_terms[_]===void 0,"Invalid term override for",s.type,_),l.$_terms[_]=c.init,u[_]=c}s.terms=u,s.args||(s.args=i.args),s.prepare=r.prepare(s.prepare,i.prepare),s.coerce&&(typeof s.coerce=="function"&&(s.coerce={method:s.coerce}),s.coerce.from&&!Array.isArray(s.coerce.from)&&(s.coerce={method:s.coerce.method,from:[].concat(s.coerce.from)})),s.coerce=r.coerce(s.coerce,i.coerce),s.validate=r.validate(s.validate,i.validate);const f=Object.assign({},i.rules);if(s.rules)for(const _ in s.rules){const c=s.rules[_];o(typeof c=="object","Invalid rule definition for",s.type,_);let m=c.method;if(m===void 0&&(m=function(){return this.$_addRule(_)}),m&&(o(!e[_],"Rule conflict in",s.type,_),e[_]=m),o(!f[_],"Rule conflict in",s.type,_),f[_]=c,c.alias){const d=[].concat(c.alias);for(const E of d)e[E]=c.method}c.args&&(c.argsByName=new Map,c.args=c.args.map(d=>(typeof d=="string"&&(d={name:d}),o(!c.argsByName.has(d.name),"Duplicated argument name",d.name),b.isSchema(d.assert)&&(d.assert=d.assert.strict().label(d.name)),c.argsByName.set(d.name,d),d)))}s.rules=f;const h=Object.assign({},i.modifiers);if(s.modifiers)for(const _ in s.modifiers){o(!e[_],"Rule conflict in",s.type,_);const c=s.modifiers[_];o(typeof c=="function","Invalid modifier definition for",s.type,_);const m=function(d){return this.rule({[_]:d})};e[_]=m,h[_]=c}if(s.modifiers=h,s.overrides){e._super=t,l.$_super={};for(const _ in s.overrides)o(t[_],"Cannot override missing",_),s.overrides[_][b.symbols.parent]=t[_],l.$_super[_]=t[_].bind(l);Object.assign(e,s.overrides)}s.cast=Object.assign({},i.cast,s.cast);const v=Object.assign({},i.manifest,s.manifest);return v.build=r.build(s.manifest&&s.manifest.build,i.manifest&&i.manifest.build),s.manifest=v,s.rebuild=r.rebuild(s.rebuild,i.rebuild),l},r.build=function(a,n){return a&&n?function(t,e){return n(a(t,e),e)}:a||n},r.coerce=function(a,n){return a&&n?{from:a.from&&n.from?[...new Set([...a.from,...n.from])]:null,method(t,e){let l;if((!n.from||n.from.includes(typeof t))&&(l=n.method(t,e),l)){if(l.errors||l.value===void 0)return l;t=l.value}if(!a.from||a.from.includes(typeof t)){const s=a.method(t,e);if(s)return s}return l}}:a||n},r.prepare=function(a,n){return a&&n?function(t,e){const l=a(t,e);if(l){if(l.errors||l.value===void 0)return l;t=l.value}return n(t,e)||l}:a||n},r.rebuild=function(a,n){return a&&n?function(t){n(t),a(t)}:a||n},r.validate=function(a,n){return a&&n?function(t,e){const l=n(t,e);if(l){if(l.errors&&(!Array.isArray(l.errors)||l.errors.length))return l;t=l.value}return a(t,e)||l}:a||n}},2115:(S,A,g)=>{const{assert:o,clone:y,deepEqual:b,merge:p}=g(3115),r=g(2130),a=g(9415),n=g(3541),t=g(8013),e=g(2062),l=g(9017),s=g(6162),i=g(5844),u=g(8529),f=g(125),h=g(1190),v=g(6220),_={Base:class{constructor(c){this.type=c,this.$_root=null,this._definition={},this._reset()}_reset(){this._ids=new i.Ids,this._preferences=null,this._refs=new u.Manager,this._cache=null,this._valids=null,this._invalids=null,this._flags={},this._rules=[],this._singleRules=new Map,this.$_terms={},this.$_temp={ruleset:null,whens:{}}}describe(){return o(typeof l.describe=="function","Manifest functionality disabled"),l.describe(this)}allow(...c){return a.verifyFlat(c,"allow"),this._values(c,"_valids")}alter(c){o(c&&typeof c=="object"&&!Array.isArray(c),"Invalid targets argument"),o(!this._inRuleset(),"Cannot set alterations inside a ruleset");const m=this.clone();m.$_terms.alterations=m.$_terms.alterations||[];for(const d in c){const E=c[d];o(typeof E=="function","Alteration adjuster for",d,"must be a function"),m.$_terms.alterations.push({target:d,adjuster:E})}return m.$_temp.ruleset=!1,m}artifact(c){return o(c!==void 0,"Artifact cannot be undefined"),o(!this._cache,"Cannot set an artifact with a rule cache"),this.$_setFlag("artifact",c)}cast(c){return o(c===!1||typeof c=="string","Invalid to value"),o(c===!1||this._definition.cast[c],"Type",this.type,"does not support casting to",c),this.$_setFlag("cast",c===!1?void 0:c)}default(c,m){return this._default("default",c,m)}description(c){return o(c&&typeof c=="string","Description must be a non-empty string"),this.$_setFlag("description",c)}empty(c){const m=this.clone();return c!==void 0&&(c=m.$_compile(c,{override:!1})),m.$_setFlag("empty",c,{clone:!1})}error(c){return o(c,"Missing error"),o(c instanceof Error||typeof c=="function","Must provide a valid Error object or a function"),this.$_setFlag("error",c)}example(c,m={}){return o(c!==void 0,"Missing example"),a.assertOptions(m,["override"]),this._inner("examples",c,{single:!0,override:m.override})}external(c,m){return typeof c=="object"&&(o(!m,"Cannot combine options with description"),m=c.description,c=c.method),o(typeof c=="function","Method must be a function"),o(m===void 0||m&&typeof m=="string","Description must be a non-empty string"),this._inner("externals",{method:c,description:m},{single:!0})}failover(c,m){return this._default("failover",c,m)}forbidden(){return this.presence("forbidden")}id(c){return c?(o(typeof c=="string","id must be a non-empty string"),o(/^[^\.]+$/.test(c),"id cannot contain period character"),this.$_setFlag("id",c)):this.$_setFlag("id",void 0)}invalid(...c){return this._values(c,"_invalids")}label(c){return o(c&&typeof c=="string","Label name must be a non-empty string"),this.$_setFlag("label",c)}meta(c){return o(c!==void 0,"Meta cannot be undefined"),this._inner("metas",c,{single:!0})}note(...c){o(c.length,"Missing notes");for(const m of c)o(m&&typeof m=="string","Notes must be non-empty strings");return this._inner("notes",c)}only(c=!0){return o(typeof c=="boolean","Invalid mode:",c),this.$_setFlag("only",c)}optional(){return this.presence("optional")}prefs(c){o(c,"Missing preferences"),o(c.context===void 0,"Cannot override context"),o(c.externals===void 0,"Cannot override externals"),o(c.warnings===void 0,"Cannot override warnings"),o(c.debug===void 0,"Cannot override debug"),a.checkPreferences(c);const m=this.clone();return m._preferences=a.preferences(m._preferences,c),m}presence(c){return o(["optional","required","forbidden"].includes(c),"Unknown presence mode",c),this.$_setFlag("presence",c)}raw(c=!0){return this.$_setFlag("result",c?"raw":void 0)}result(c){return o(["raw","strip"].includes(c),"Unknown result mode",c),this.$_setFlag("result",c)}required(){return this.presence("required")}strict(c){const m=this.clone(),d=c!==void 0&&!c;return m._preferences=a.preferences(m._preferences,{convert:d}),m}strip(c=!0){return this.$_setFlag("result",c?"strip":void 0)}tag(...c){o(c.length,"Missing tags");for(const m of c)o(m&&typeof m=="string","Tags must be non-empty strings");return this._inner("tags",c)}unit(c){return o(c&&typeof c=="string","Unit name must be a non-empty string"),this.$_setFlag("unit",c)}valid(...c){a.verifyFlat(c,"valid");const m=this.allow(...c);return m.$_setFlag("only",!!m._valids,{clone:!1}),m}when(c,m){const d=this.clone();d.$_terms.whens||(d.$_terms.whens=[]);const E=n.when(d,c,m);if(!["any","link"].includes(d.type)){const R=E.is?[E]:E.switch;for(const w of R)o(!w.then||w.then.type==="any"||w.then.type===d.type,"Cannot combine",d.type,"with",w.then&&w.then.type),o(!w.otherwise||w.otherwise.type==="any"||w.otherwise.type===d.type,"Cannot combine",d.type,"with",w.otherwise&&w.otherwise.type)}return d.$_terms.whens.push(E),d.$_mutateRebuild()}cache(c){o(!this._inRuleset(),"Cannot set caching inside a ruleset"),o(!this._cache,"Cannot override schema cache"),o(this._flags.artifact===void 0,"Cannot cache a rule with an artifact");const m=this.clone();return m._cache=c||r.provider.provision(),m.$_temp.ruleset=!1,m}clone(){const c=Object.create(Object.getPrototypeOf(this));return this._assign(c)}concat(c){o(a.isSchema(c),"Invalid schema object"),o(this.type==="any"||c.type==="any"||c.type===this.type,"Cannot merge type",this.type,"with another type:",c.type),o(!this._inRuleset(),"Cannot concatenate onto a schema with open ruleset"),o(!c._inRuleset(),"Cannot concatenate a schema with open ruleset");let m=this.clone();if(this.type==="any"&&c.type!=="any"){const d=c.clone();for(const E of Object.keys(m))E!=="type"&&(d[E]=m[E]);m=d}m._ids.concat(c._ids),m._refs.register(c,u.toSibling),m._preferences=m._preferences?a.preferences(m._preferences,c._preferences):c._preferences,m._valids=v.merge(m._valids,c._valids,c._invalids),m._invalids=v.merge(m._invalids,c._invalids,c._valids);for(const d of c._singleRules.keys())m._singleRules.has(d)&&(m._rules=m._rules.filter(E=>E.keep||E.name!==d),m._singleRules.delete(d));for(const d of c._rules)c._definition.rules[d.method].multi||m._singleRules.set(d.name,d),m._rules.push(d);if(m._flags.empty&&c._flags.empty){m._flags.empty=m._flags.empty.concat(c._flags.empty);const d=Object.assign({},c._flags);delete d.empty,p(m._flags,d)}else if(c._flags.empty){m._flags.empty=c._flags.empty;const d=Object.assign({},c._flags);delete d.empty,p(m._flags,d)}else p(m._flags,c._flags);for(const d in c.$_terms){const E=c.$_terms[d];E?m.$_terms[d]?m.$_terms[d]=m.$_terms[d].concat(E):m.$_terms[d]=E.slice():m.$_terms[d]||(m.$_terms[d]=E)}return this.$_root._tracer&&this.$_root._tracer._combine(m,[this,c]),m.$_mutateRebuild()}extend(c){return o(!c.base,"Cannot extend type with another base"),e.type(this,c)}extract(c){return c=Array.isArray(c)?c:c.split("."),this._ids.reach(c)}fork(c,m){o(!this._inRuleset(),"Cannot fork inside a ruleset");let d=this;for(let E of[].concat(c))E=Array.isArray(E)?E:E.split("."),d=d._ids.fork(E,m,d);return d.$_temp.ruleset=!1,d}isAsync(){var c;if(!((c=this.$_terms.externals)===null||c===void 0)&&c.length)return!0;if(this.$_terms.whens)for(const w of this.$_terms.whens){var m,d;if((m=w.then)!==null&&m!==void 0&&m.isAsync()||(d=w.otherwise)!==null&&d!==void 0&&d.isAsync())return!0;if(w.switch)for(const N of w.switch){var E,R;if((E=N.then)!==null&&E!==void 0&&E.isAsync()||(R=N.otherwise)!==null&&R!==void 0&&R.isAsync())return!0}}return!1}rule(c){const m=this._definition;a.assertOptions(c,Object.keys(m.modifiers)),o(this.$_temp.ruleset!==!1,"Cannot apply rules to empty ruleset or the last rule added does not support rule properties");const d=this.$_temp.ruleset===null?this._rules.length-1:this.$_temp.ruleset;o(d>=0&&d<this._rules.length,"Cannot apply rules to empty ruleset");const E=this.clone();for(let R=d;R<E._rules.length;++R){const w=E._rules[R],N=y(w);for(const I in c)m.modifiers[I](N,c[I]),o(N.name===w.name,"Cannot change rule name");E._rules[R]=N,E._singleRules.get(N.name)===w&&E._singleRules.set(N.name,N)}return E.$_temp.ruleset=!1,E.$_mutateRebuild()}get ruleset(){o(!this._inRuleset(),"Cannot start a new ruleset without closing the previous one");const c=this.clone();return c.$_temp.ruleset=c._rules.length,c}get $(){return this.ruleset}tailor(c){c=[].concat(c),o(!this._inRuleset(),"Cannot tailor inside a ruleset");let m=this;if(this.$_terms.alterations)for(const{target:d,adjuster:E}of this.$_terms.alterations)c.includes(d)&&(m=E(m),o(a.isSchema(m),"Alteration adjuster for",d,"failed to return a schema object"));return m=m.$_modify({each:d=>d.tailor(c),ref:!1}),m.$_temp.ruleset=!1,m.$_mutateRebuild()}tracer(){return f.location?f.location(this):this}validate(c,m){return h.entry(c,this,m)}validateAsync(c,m){return h.entryAsync(c,this,m)}$_addRule(c){typeof c=="string"&&(c={name:c}),o(c&&typeof c=="object","Invalid options"),o(c.name&&typeof c.name=="string","Invalid rule name");for(const w in c)o(w[0]!=="_","Cannot set private rule properties");const m=Object.assign({},c);m._resolve=[],m.method=m.method||m.name;const d=this._definition.rules[m.method],E=m.args;o(d,"Unknown rule",m.method);const R=this.clone();if(E){o(Object.keys(E).length===1||Object.keys(E).length===this._definition.rules[m.name].args.length,"Invalid rule definition for",this.type,m.name);for(const w in E){let N=E[w];if(d.argsByName){const I=d.argsByName.get(w);if(I.ref&&a.isResolvable(N))m._resolve.push(w),R.$_mutateRegister(N);else if(I.normalize&&(N=I.normalize(N),E[w]=N),I.assert){const T=a.validateArg(N,w,I);o(!T,T,"or reference")}}N!==void 0?E[w]=N:delete E[w]}}return d.multi||(R._ruleRemove(m.name,{clone:!1}),R._singleRules.set(m.name,m)),R.$_temp.ruleset===!1&&(R.$_temp.ruleset=null),d.priority?R._rules.unshift(m):R._rules.push(m),R}$_compile(c,m){return n.schema(this.$_root,c,m)}$_createError(c,m,d,E,R,w={}){const N=w.flags!==!1?this._flags:{},I=w.messages?s.merge(this._definition.messages,w.messages):this._definition.messages;return new t.Report(c,m,d,N,I,E,R)}$_getFlag(c){return this._flags[c]}$_getRule(c){return this._singleRules.get(c)}$_mapLabels(c){return c=Array.isArray(c)?c:c.split("."),this._ids.labels(c)}$_match(c,m,d,E){(d=Object.assign({},d)).abortEarly=!0,d._externals=!1,m.snapshot();const R=!h.validate(c,this,m,d,E).errors;return m.restore(),R}$_modify(c){return a.assertOptions(c,["each","once","ref","schema"]),i.schema(this,c)||this}$_mutateRebuild(){return o(!this._inRuleset(),"Cannot add this rule inside a ruleset"),this._refs.reset(),this._ids.reset(),this.$_modify({each:(c,{source:m,name:d,path:E,key:R})=>{const w=this._definition[m][d]&&this._definition[m][d].register;w!==!1&&this.$_mutateRegister(c,{family:w,key:R})}}),this._definition.rebuild&&this._definition.rebuild(this),this.$_temp.ruleset=!1,this}$_mutateRegister(c,{family:m,key:d}={}){this._refs.register(c,m),this._ids.register(c,{key:d})}$_property(c){return this._definition.properties[c]}$_reach(c){return this._ids.reach(c)}$_rootReferences(){return this._refs.roots()}$_setFlag(c,m,d={}){o(c[0]==="_"||!this._inRuleset(),"Cannot set flag inside a ruleset");const E=this._definition.flags[c]||{};if(b(m,E.default)&&(m=void 0),b(m,this._flags[c]))return this;const R=d.clone!==!1?this.clone():this;return m!==void 0?(R._flags[c]=m,R.$_mutateRegister(m)):delete R._flags[c],c[0]!=="_"&&(R.$_temp.ruleset=!1),R}$_parent(c,...m){return this[c][a.symbols.parent].call(this,...m)}$_validate(c,m,d){return h.validate(c,this,m,d)}_assign(c){c.type=this.type,c.$_root=this.$_root,c.$_temp=Object.assign({},this.$_temp),c.$_temp.whens={},c._ids=this._ids.clone(),c._preferences=this._preferences,c._valids=this._valids&&this._valids.clone(),c._invalids=this._invalids&&this._invalids.clone(),c._rules=this._rules.slice(),c._singleRules=y(this._singleRules,{shallow:!0}),c._refs=this._refs.clone(),c._flags=Object.assign({},this._flags),c._cache=null,c.$_terms={};for(const m in this.$_terms)c.$_terms[m]=this.$_terms[m]?this.$_terms[m].slice():null;c.$_super={};for(const m in this.$_super)c.$_super[m]=this._super[m].bind(c);return c}_bare(){const c=this.clone();c._reset();const m=c._definition.terms;for(const d in m){const E=m[d];c.$_terms[d]=E.init}return c.$_mutateRebuild()}_default(c,m,d={}){return a.assertOptions(d,"literal"),o(m!==void 0,"Missing",c,"value"),o(typeof m=="function"||!d.literal,"Only function value supports literal option"),typeof m=="function"&&d.literal&&(m={[a.symbols.literal]:!0,literal:m}),this.$_setFlag(c,m)}_generate(c,m,d){if(!this.$_terms.whens)return{schema:this};const E=[],R=[];for(let I=0;I<this.$_terms.whens.length;++I){const T=this.$_terms.whens[I];if(T.concat){E.push(T.concat),R.push(`${I}.concat`);continue}const D=T.ref?T.ref.resolve(c,m,d):c,B=T.is?[T]:T.switch,F=R.length;for(let j=0;j<B.length;++j){const{is:U,then:H,otherwise:q}=B[j],Z=`${I}${T.switch?"."+j:""}`;if(U.$_match(D,m.nest(U,`${Z}.is`),d)){if(H){const Q=m.localize([...m.path,`${Z}.then`],m.ancestors,m.schemas),{schema:V,id:J}=H._generate(c,Q,d);E.push(V),R.push(`${Z}.then${J?`(${J})`:""}`);break}}else if(q){const Q=m.localize([...m.path,`${Z}.otherwise`],m.ancestors,m.schemas),{schema:V,id:J}=q._generate(c,Q,d);E.push(V),R.push(`${Z}.otherwise${J?`(${J})`:""}`);break}}if(T.break&&R.length>F)break}const w=R.join(", ");if(m.mainstay.tracer.debug(m,"rule","when",w),!w)return{schema:this};if(!m.mainstay.tracer.active&&this.$_temp.whens[w])return{schema:this.$_temp.whens[w],id:w};let N=this;this._definition.generate&&(N=this._definition.generate(this,c,m,d));for(const I of E)N=N.concat(I);return this.$_root._tracer&&this.$_root._tracer._combine(N,[this,...E]),this.$_temp.whens[w]=N,{schema:N,id:w}}_inner(c,m,d={}){o(!this._inRuleset(),`Cannot set ${c} inside a ruleset`);const E=this.clone();return E.$_terms[c]&&!d.override||(E.$_terms[c]=[]),d.single?E.$_terms[c].push(m):E.$_terms[c].push(...m),E.$_temp.ruleset=!1,E}_inRuleset(){return this.$_temp.ruleset!==null&&this.$_temp.ruleset!==!1}_ruleRemove(c,m={}){if(!this._singleRules.has(c))return this;const d=m.clone!==!1?this.clone():this;d._singleRules.delete(c);const E=[];for(let R=0;R<d._rules.length;++R){const w=d._rules[R];w.name!==c||w.keep?E.push(w):d._inRuleset()&&R<d.$_temp.ruleset&&--d.$_temp.ruleset}return d._rules=E,d}_values(c,m){a.verifyFlat(c,m.slice(1,-1));const d=this.clone(),E=c[0]===a.symbols.override;if(E&&(c=c.slice(1)),!d[m]&&c.length?d[m]=new v:E&&(d[m]=c.length?new v:null,d.$_mutateRebuild()),!d[m])return d;E&&d[m].override();for(const R of c){o(R!==void 0,"Cannot call allow/valid/invalid with undefined"),o(R!==a.symbols.override,"Override must be the first value");const w=m==="_invalids"?"_valids":"_invalids";d[w]&&(d[w].remove(R),d[w].length||(o(m==="_valids"||!d._flags.only,"Setting invalid value",R,"leaves schema rejecting all values due to previous valid rule"),d[w]=null)),d[m].add(R,d._refs)}return d}get"~standard"(){const c=d=>{let E;return E=t.ValidationError.isError(d)?d.details.map(({message:R,path:w})=>({message:R,path:w})):[{message:d.message}],{issues:E}},m=d=>({value:d});return{version:1,vendor:"joi",validate:d=>{const E=h.standard(d,this);return E instanceof Promise?E.then(m,c):E.error?c(E.error):m(E.value)}}}}};_.Base.prototype[a.symbols.any]={version:a.version,compile:n.compile,root:"$_root"},_.Base.prototype.isImmutable=!0,_.Base.prototype.deny=_.Base.prototype.invalid,_.Base.prototype.disallow=_.Base.prototype.invalid,_.Base.prototype.equal=_.Base.prototype.valid,_.Base.prototype.exist=_.Base.prototype.required,_.Base.prototype.not=_.Base.prototype.invalid,_.Base.prototype.options=_.Base.prototype.prefs,_.Base.prototype.preferences=_.Base.prototype.prefs,S.exports=new _.Base},2130:(S,A,g)=>{const{assert:o,clone:y}=g(3115),b=g(9415),p={max:1e3,supported:new Set(["undefined","boolean","number","string"])};A.provider={provision:r=>new p.Cache(r)},p.Cache=class{constructor(r={}){b.assertOptions(r,["max"]),o(r.max===void 0||r.max&&r.max>0&&isFinite(r.max),"Invalid max cache size"),this._max=r.max||p.max,this._map=new Map,this._list=new p.List}get length(){return this._map.size}set(r,a){if(r!==null&&!p.supported.has(typeof r))return;let n=this._map.get(r);if(n)return n.value=a,void this._list.first(n);n=this._list.unshift({key:r,value:a}),this._map.set(r,n),this._compact()}get(r){const a=this._map.get(r);if(a)return this._list.first(a),y(a.value)}_compact(){if(this._map.size>this._max){const r=this._list.pop();this._map.delete(r.key)}}},p.List=class{constructor(){this.tail=null,this.head=null}unshift(r){return r.next=null,r.prev=this.head,this.head&&(this.head.next=r),this.head=r,this.tail||(this.tail=r),r}first(r){r!==this.head&&(this._remove(r),this.unshift(r))}pop(){return this._remove(this.tail)}_remove(r){const{next:a,prev:n}=r;return a.prev=n,n&&(n.next=a),r===this.tail&&(this.tail=a),r.prev=null,r.next=null,r}}},2588:(S,A,g)=>{const{assert:o}=g(3115),y=g(680),b=g(9415),p=g(1532),r={isDate:function(a){return a instanceof Date}};S.exports=y.extend({type:"date",coerce:{from:["number","string"],method:(a,{schema:n})=>({value:r.parse(a,n._flags.format)||a})},validate(a,{schema:n,error:t,prefs:e}){if(a instanceof Date&&!isNaN(a.getTime()))return;const l=n._flags.format;return e.convert&&l&&typeof a=="string"?{value:a,errors:t("date.format",{format:l})}:{value:a,errors:t("date.base")}},rules:{compare:{method:!1,validate(a,n,{date:t},{name:e,operator:l,args:s}){const i=t==="now"?Date.now():t.getTime();return b.compare(a.getTime(),i,l)?a:n.error("date."+e,{limit:s.date,value:a})},args:[{name:"date",ref:!0,normalize:a=>a==="now"?a:r.parse(a),assert:a=>a!==null,message:"must have a valid date format"}]},format:{method(a){return o(["iso","javascript","unix"].includes(a),"Unknown date format",a),this.$_setFlag("format",a)}},greater:{method(a){return this.$_addRule({name:"greater",method:"compare",args:{date:a},operator:">"})}},iso:{method(){return this.format("iso")}},less:{method(a){return this.$_addRule({name:"less",method:"compare",args:{date:a},operator:"<"})}},max:{method(a){return this.$_addRule({name:"max",method:"compare",args:{date:a},operator:"<="})}},min:{method(a){return this.$_addRule({name:"min",method:"compare",args:{date:a},operator:">="})}},timestamp:{method(a="javascript"){return o(["javascript","unix"].includes(a),'"type" must be one of "javascript, unix"'),this.format(a)}}},cast:{number:{from:r.isDate,to:(a,n)=>a.getTime()},string:{from:r.isDate,to:(a,{prefs:n})=>p.date(a,n)}},messages:{"date.base":"{{#label}} must be a valid date","date.format":'{{#label}} must be in {msg("date.format." + #format) || #format} format',"date.greater":"{{#label}} must be greater than {{:#limit}}","date.less":"{{#label}} must be less than {{:#limit}}","date.max":"{{#label}} must be less than or equal to {{:#limit}}","date.min":"{{#label}} must be greater than or equal to {{:#limit}}","date.format.iso":"ISO 8601 date","date.format.javascript":"timestamp or number of milliseconds","date.format.unix":"timestamp or number of seconds"}}),r.parse=function(a,n){if(a instanceof Date)return a;if(typeof a!="string"&&(isNaN(a)||!isFinite(a))||/^\s*$/.test(a))return null;if(n==="iso")return b.isIsoDate(a)?r.date(a.toString()):null;const t=a;if(typeof a=="string"&&/^[+-]?\d+(\.\d+)?$/.test(a)&&(a=parseFloat(a)),n){if(n==="javascript")return r.date(1*a);if(n==="unix")return r.date(1e3*a);if(typeof t=="string")return null}return r.date(a)},r.date=function(a){const n=new Date(a);return isNaN(n.getTime())?null:n}},2591:(S,A,g)=>{const{assert:o,deepEqual:y,reach:b}=g(3115),p=g(680),r=g(9415),a=g(3541),n={};S.exports=p.extend({type:"array",flags:{single:{default:!1},sparse:{default:!1}},terms:{items:{init:[],manifest:"schema"},ordered:{init:[],manifest:"schema"},_exclusions:{init:[]},_inclusions:{init:[]},_requireds:{init:[]}},coerce:{from:"object",method(t,{schema:e,state:l,prefs:s}){if(!Array.isArray(t))return;const i=e.$_getRule("sort");return i?n.sort(e,t,i.args.options,l,s):void 0}},validate(t,{schema:e,error:l}){if(!Array.isArray(t)){if(e._flags.single){const s=[t];return s[r.symbols.arraySingle]=!0,{value:s}}return{errors:l("array.base")}}if(e.$_getRule("items")||e.$_terms.externals)return{value:t.slice()}},rules:{has:{method(t){t=this.$_compile(t,{appendPath:!0});const e=this.$_addRule({name:"has",args:{schema:t}});return e.$_mutateRegister(t),e},validate(t,{state:e,prefs:l,error:s},{schema:i}){const u=[t,...e.ancestors];for(let h=0;h<t.length;++h){const v=e.localize([...e.path,h],u,i);if(i.$_match(t[h],v,l))return t}const f=i._flags.label;return f?s("array.hasKnown",{patternLabel:f}):s("array.hasUnknown",null)},multi:!0},items:{method(...t){r.verifyFlat(t,"items");const e=this.$_addRule("items");for(let l=0;l<t.length;++l){const s=r.tryWithPath(()=>this.$_compile(t[l]),l,{append:!0});e.$_terms.items.push(s)}return e.$_mutateRebuild()},validate(t,{schema:e,error:l,state:s,prefs:i,errorsArray:u}){const f=e.$_terms._requireds.slice(),h=e.$_terms.ordered.slice(),v=[...e.$_terms._inclusions,...f],_=!t[r.symbols.arraySingle];delete t[r.symbols.arraySingle];const c=u();let m=t.length;for(let d=0;d<m;++d){const E=t[d];let R=!1,w=!1;const N=_?d:new Number(d),I=[...s.path,N];if(!e._flags.sparse&&E===void 0){if(c.push(l("array.sparse",{key:N,path:I,pos:d,value:void 0},s.localize(I))),i.abortEarly)return c;h.shift();continue}const T=[t,...s.ancestors];for(const j of e.$_terms._exclusions)if(j.$_match(E,s.localize(I,T,j),i,{presence:"ignore"})){if(c.push(l("array.excludes",{pos:d,value:E},s.localize(I))),i.abortEarly)return c;R=!0,h.shift();break}if(R)continue;if(e.$_terms.ordered.length){if(h.length){const j=h.shift(),U=j.$_validate(E,s.localize(I,T,j),i);if(U.errors){if(c.push(...U.errors),i.abortEarly)return c}else if(j._flags.result==="strip")n.fastSplice(t,d),--d,--m;else{if(!e._flags.sparse&&U.value===void 0){if(c.push(l("array.sparse",{key:N,path:I,pos:d,value:void 0},s.localize(I))),i.abortEarly)return c;continue}t[d]=U.value}continue}if(!e.$_terms.items.length){if(c.push(l("array.orderedLength",{pos:d,limit:e.$_terms.ordered.length})),i.abortEarly)return c;break}}const D=[];let B=f.length;for(let j=0;j<B;++j){const U=s.localize(I,T,f[j]);U.snapshot();const H=f[j].$_validate(E,U,i);if(D[j]=H,!H.errors){if(U.commit(),t[d]=H.value,w=!0,n.fastSplice(f,j),--j,--B,!e._flags.sparse&&H.value===void 0&&(c.push(l("array.sparse",{key:N,path:I,pos:d,value:void 0},s.localize(I))),i.abortEarly))return c;break}U.restore()}if(w)continue;const F=i.stripUnknown&&!!i.stripUnknown.arrays||!1;B=v.length;for(const j of v){let U;const H=f.indexOf(j);if(H!==-1)U=D[H];else{const q=s.localize(I,T,j);if(q.snapshot(),U=j.$_validate(E,q,i),!U.errors){q.commit(),j._flags.result==="strip"?(n.fastSplice(t,d),--d,--m):e._flags.sparse||U.value!==void 0?t[d]=U.value:(c.push(l("array.sparse",{key:N,path:I,pos:d,value:void 0},s.localize(I))),R=!0),w=!0;break}q.restore()}if(B===1){if(F){n.fastSplice(t,d),--d,--m,w=!0;break}if(c.push(...U.errors),i.abortEarly)return c;R=!0;break}}if(!R&&(e.$_terms._inclusions.length||e.$_terms._requireds.length)&&!w){if(F){n.fastSplice(t,d),--d,--m;continue}if(c.push(l("array.includes",{pos:d,value:E},s.localize(I))),i.abortEarly)return c}}return f.length&&n.fillMissedErrors(e,c,f,t,s,i),h.length&&(n.fillOrderedErrors(e,c,h,t,s,i),c.length||n.fillDefault(h,t,s,i)),c.length?c:t},priority:!0,manifest:!1},length:{method(t){return this.$_addRule({name:"length",args:{limit:t},operator:"="})},validate:(t,e,{limit:l},{name:s,operator:i,args:u})=>r.compare(t.length,l,i)?t:e.error("array."+s,{limit:u.limit,value:t}),args:[{name:"limit",ref:!0,assert:r.limit,message:"must be a positive integer"}]},max:{method(t){return this.$_addRule({name:"max",method:"length",args:{limit:t},operator:"<="})}},min:{method(t){return this.$_addRule({name:"min",method:"length",args:{limit:t},operator:">="})}},ordered:{method(...t){r.verifyFlat(t,"ordered");const e=this.$_addRule("items");for(let l=0;l<t.length;++l){const s=r.tryWithPath(()=>this.$_compile(t[l]),l,{append:!0});n.validateSingle(s,e),e.$_mutateRegister(s),e.$_terms.ordered.push(s)}return e.$_mutateRebuild()}},single:{method(t){const e=t===void 0||!!t;return o(!e||!this._flags._arrayItems,"Cannot specify single rule when array has array items"),this.$_setFlag("single",e)}},sort:{method(t={}){r.assertOptions(t,["by","order"]);const e={order:t.order||"ascending"};return t.by&&(e.by=a.ref(t.by,{ancestor:0}),o(!e.by.ancestor,"Cannot sort by ancestor")),this.$_addRule({name:"sort",args:{options:e}})},validate(t,{error:e,state:l,prefs:s,schema:i},{options:u}){const{value:f,errors:h}=n.sort(i,t,u,l,s);if(h)return h;for(let v=0;v<t.length;++v)if(t[v]!==f[v])return e("array.sort",{order:u.order,by:u.by?u.by.key:"value"});return t},convert:!0},sparse:{method(t){const e=t===void 0||!!t;return this._flags.sparse===e?this:(e?this.clone():this.$_addRule("items")).$_setFlag("sparse",e,{clone:!1})}},unique:{method(t,e={}){o(!t||typeof t=="function"||typeof t=="string","comparator must be a function or a string"),r.assertOptions(e,["ignoreUndefined","separator"]);const l={name:"unique",args:{options:e,comparator:t}};if(t)if(typeof t=="string"){const s=r.default(e.separator,".");l.path=s?t.split(s):[t]}else l.comparator=t;return this.$_addRule(l)},validate(t,{state:e,error:l,schema:s},{comparator:i,options:u},{comparator:f,path:h}){const v={string:Object.create(null),number:Object.create(null),undefined:Object.create(null),boolean:Object.create(null),bigint:Object.create(null),object:new Map,function:new Map,custom:new Map},_=f||y,c=u.ignoreUndefined;for(let m=0;m<t.length;++m){const d=h?b(t[m],h):t[m],E=f?v.custom:v[typeof d];if(o(E,"Failed to find unique map container for type",typeof d),E instanceof Map){const R=E.entries();let w;for(;!(w=R.next()).done;)if(_(w.value[0],d)){const N=e.localize([...e.path,m],[t,...e.ancestors]),I={pos:m,value:t[m],dupePos:w.value[1],dupeValue:t[w.value[1]]};return h&&(I.path=i),l("array.unique",I,N)}E.set(d,m)}else{if((!c||d!==void 0)&&E[d]!==void 0){const R={pos:m,value:t[m],dupePos:E[d],dupeValue:t[E[d]]};return h&&(R.path=i),l("array.unique",R,e.localize([...e.path,m],[t,...e.ancestors]))}E[d]=m}}return t},args:["comparator","options"],multi:!0}},overrides:{isAsync(){var t;if((t=this.$_terms.externals)!==null&&t!==void 0&&t.length)return!0;for(const e of this.$_terms.items)if(e.isAsync())return!0;for(const e of this.$_terms.ordered)if(e.isAsync())return!0;return!1}},cast:{set:{from:Array.isArray,to:(t,e)=>new Set(t)}},rebuild(t){t.$_terms._inclusions=[],t.$_terms._exclusions=[],t.$_terms._requireds=[];for(const e of t.$_terms.items)n.validateSingle(e,t),e._flags.presence==="required"?t.$_terms._requireds.push(e):e._flags.presence==="forbidden"?t.$_terms._exclusions.push(e):t.$_terms._inclusions.push(e);for(const e of t.$_terms.ordered)n.validateSingle(e,t)},manifest:{build:(t,e)=>(e.items&&(t=t.items(...e.items)),e.ordered&&(t=t.ordered(...e.ordered)),t)},messages:{"array.base":"{{#label}} must be an array","array.excludes":"{{#label}} contains an excluded value","array.hasKnown":"{{#label}} does not contain at least one required match for type {:#patternLabel}","array.hasUnknown":"{{#label}} does not contain at least one required match","array.includes":"{{#label}} does not match any of the allowed types","array.includesRequiredBoth":"{{#label}} does not contain {{#knownMisses}} and {{#unknownMisses}} other required value(s)","array.includesRequiredKnowns":"{{#label}} does not contain {{#knownMisses}}","array.includesRequiredUnknowns":"{{#label}} does not contain {{#unknownMisses}} required value(s)","array.length":"{{#label}} must contain {{#limit}} items","array.max":"{{#label}} must contain less than or equal to {{#limit}} items","array.min":"{{#label}} must contain at least {{#limit}} items","array.orderedLength":"{{#label}} must contain at most {{#limit}} items","array.sort":"{{#label}} must be sorted in {#order} order by {{#by}}","array.sort.mismatching":"{{#label}} cannot be sorted due to mismatching types","array.sort.unsupported":"{{#label}} cannot be sorted due to unsupported type {#type}","array.sparse":"{{#label}} must not be a sparse array item","array.unique":"{{#label}} contains a duplicate value"}}),n.fillMissedErrors=function(t,e,l,s,i,u){const f=[];let h=0;for(const v of l){const _=v._flags.label;_?f.push(_):++h}f.length?h?e.push(t.$_createError("array.includesRequiredBoth",s,{knownMisses:f,unknownMisses:h},i,u)):e.push(t.$_createError("array.includesRequiredKnowns",s,{knownMisses:f},i,u)):e.push(t.$_createError("array.includesRequiredUnknowns",s,{unknownMisses:h},i,u))},n.fillOrderedErrors=function(t,e,l,s,i,u){const f=[];for(const h of l)h._flags.presence==="required"&&f.push(h);f.length&&n.fillMissedErrors(t,e,f,s,i,u)},n.fillDefault=function(t,e,l,s){const i=[];let u=!0;for(let f=t.length-1;f>=0;--f){const h=t[f],v=[e,...l.ancestors],_=h.$_validate(void 0,l.localize(l.path,v,h),s).value;if(u){if(_===void 0)continue;u=!1}i.unshift(_)}i.length&&e.push(...i)},n.fastSplice=function(t,e){let l=e;for(;l<t.length;)t[l++]=t[l];--t.length},n.validateSingle=function(t,e){(t.type==="array"||t._flags._arrayItems)&&(o(!e._flags.single,"Cannot specify array item with single rule enabled"),e.$_setFlag("_arrayItems",!0,{clone:!1}))},n.sort=function(t,e,l,s,i){const u=l.order==="ascending"?1:-1,f=-1*u,h=u,v=(_,c)=>{let m=n.compare(_,c,f,h);if(m!==null||(l.by&&(_=l.by.resolve(_,s,i),c=l.by.resolve(c,s,i)),m=n.compare(_,c,f,h),m!==null))return m;const d=typeof _;if(d!==typeof c)throw t.$_createError("array.sort.mismatching",e,null,s,i);if(d!=="number"&&d!=="string")throw t.$_createError("array.sort.unsupported",e,{type:d},s,i);return d==="number"?(_-c)*u:_<c?f:h};try{return{value:e.slice().sort(v)}}catch(_){return{errors:_}}},n.compare=function(t,e,l,s){return t===e?0:t===void 0?1:e===void 0?-1:t===null?s:e===null?l:null}},2847:(S,A,g)=>{const o=g(8253),y=g(7125),b=g(8669),p=g(86),r={};S.exports=function(a,n,t={}){return typeof n!="object"&&(n=[n]),o(!Array.isArray(n)||n.length,"Values array cannot be empty"),typeof a=="string"?r.string(a,n,t):Array.isArray(a)?r.array(a,n,t):(o(typeof a=="object","Reference must be string or an object"),r.object(a,n,t))},r.array=function(a,n,t){if(Array.isArray(n)||(n=[n]),!a.length||t.only&&t.once&&a.length!==n.length)return!1;let e;const l=new Map;for(const i of n)if(t.deep&&i&&typeof i=="object"){e=e??r.compare(t);let u=!1;for(const[f,h]of l.entries())if(e(f,i)){++h.allowed,u=!0;break}u||l.set(i,{allowed:1,hits:0})}else{const u=l.get(i);u?++u.allowed:l.set(i,{allowed:1,hits:0})}let s=0;for(const i of a){let u;if(t.deep&&i&&typeof i=="object"){e=e??r.compare(t);for(const[f,h]of l.entries())if(e(f,i)){u=h;break}}else u=l.get(i);if(u&&(++u.hits,++s,t.once&&u.hits>u.allowed))return!1}if(t.only&&s!==a.length)return!1;for(const i of l.values())if(i.hits!==i.allowed&&i.hits<i.allowed&&!t.part)return!1;return!!s},r.object=function(a,n,t){o(t.once===void 0,"Cannot use option once with object");const e=p.keys(a,t);if(!e.length)return!1;if(Array.isArray(n))return r.array(e,n,t);const l=Object.getOwnPropertySymbols(n).filter(f=>n.propertyIsEnumerable(f)),s=[...Object.keys(n),...l],i=r.compare(t),u=new Set(s);for(const f of e)if(u.has(f)){if(!i(n[f],a[f]))return!1;u.delete(f)}else if(t.only)return!1;return!u.size||!!t.part&&u.size<s.length},r.string=function(a,n,t){if(a==="")return n.length===1&&n[0]===""||!t.once&&!n.some(f=>f!=="");const e=new Map,l=[];for(const f of n)if(o(typeof f=="string","Cannot compare string reference to non-string value"),f){const h=e.get(f);h?++h.allowed:(e.set(f,{allowed:1,hits:0}),l.push(b(f)))}else if(t.once||t.only)return!1;if(!l.length)return!0;const s=new RegExp(`(${l.join("|")})`,"g"),i=a.replace(s,(f,h)=>(++e.get(h).hits,""));if(t.only&&i)return!1;let u=!1;for(const f of e.values())if(f.hits&&(u=!0),f.hits!==f.allowed&&(f.hits<f.allowed&&!t.part||t.once))return!1;return!!u},r.compare=function(a){if(!a.deep)return r.shallow;const n=a.only!==void 0,t=a.part!==void 0,e={prototype:n?a.only:!!t&&!a.part,part:n?!a.only:!!t&&a.part};return(l,s)=>y(l,s,e)},r.shallow=function(a,n){return a===n}},2888:(S,A,g)=>{const{applyToDefaults:o,assert:y,clone:b}=g(3115),p=g(8248),r=g(680),a=g(9415),n=g(3541),t=g(8013),e=g(8529),l=g(1532),s={renameDefaults:{alias:!1,multiple:!1,override:!1}};S.exports=r.extend({type:"_keys",properties:{typeof:"object"},flags:{unknown:{default:void 0}},terms:{dependencies:{init:null},keys:{init:null,manifest:{mapped:{from:"schema",to:"key"}}},patterns:{init:null},renames:{init:null}},args:(i,u)=>i.keys(u),validate(i,{schema:u,error:f,state:h,prefs:v}){if(!i||typeof i!==u.$_property("typeof")||Array.isArray(i))return{value:i,errors:f("object.base",{type:u.$_property("typeof")})};if(!(u.$_terms.renames||u.$_terms.dependencies||u.$_terms.keys||u.$_terms.patterns||u.$_terms.externals))return;i=s.clone(i,v);const _=[];if(u.$_terms.renames&&!s.rename(u,i,h,v,_))return{value:i,errors:_};if(!u.$_terms.keys&&!u.$_terms.patterns&&!u.$_terms.dependencies)return{value:i,errors:_};const c=new Set(Object.keys(i));if(u.$_terms.keys){const m=[i,...h.ancestors];for(const d of u.$_terms.keys){const E=d.key,R=i[E];c.delete(E);const w=h.localize([...h.path,E],m,d),N=d.schema.$_validate(R,w,v);if(N.errors){if(v.abortEarly)return{value:i,errors:N.errors};N.value!==void 0&&(i[E]=N.value),_.push(...N.errors)}else d.schema._flags.result==="strip"||N.value===void 0&&R!==void 0?delete i[E]:N.value!==void 0&&(i[E]=N.value)}}if(c.size||u._flags._hasPatternMatch){const m=s.unknown(u,i,c,_,h,v);if(m)return m}if(u.$_terms.dependencies)for(const m of u.$_terms.dependencies){if(m.key!==null&&s.isPresent(m.options)(m.key.resolve(i,h,v,null,{shadow:!1}))===!1)continue;const d=s.dependencies[m.rel](u,m,i,h,v);if(d){const E=u.$_createError(d.code,i,d.context,h,v);if(v.abortEarly)return{value:i,errors:E};_.push(E)}}return{value:i,errors:_}},rules:{and:{method(...i){return a.verifyFlat(i,"and"),s.dependency(this,"and",null,i)}},append:{method(i){return i==null||Object.keys(i).length===0?this:this.keys(i)}},assert:{method(i,u,f){l.isTemplate(i)||(i=n.ref(i)),y(f===void 0||typeof f=="string","Message must be a string"),u=this.$_compile(u,{appendPath:!0});const h=this.$_addRule({name:"assert",args:{subject:i,schema:u,message:f}});return h.$_mutateRegister(i),h.$_mutateRegister(u),h},validate(i,{error:u,prefs:f,state:h},{subject:v,schema:_,message:c}){const m=v.resolve(i,h,f),d=e.isRef(v)?v.absolute(h):[];return _.$_match(m,h.localize(d,[i,...h.ancestors],_),f)?i:u("object.assert",{subject:v,message:c})},args:["subject","schema","message"],multi:!0},instance:{method(i,u){return y(typeof i=="function","constructor must be a function"),u=u||i.name,this.$_addRule({name:"instance",args:{constructor:i,name:u}})},validate:(i,u,{constructor:f,name:h})=>i instanceof f?i:u.error("object.instance",{type:h,value:i}),args:["constructor","name"]},keys:{method(i){y(i===void 0||typeof i=="object","Object schema must be a valid object"),y(!a.isSchema(i),"Object schema cannot be a joi schema");const u=this.clone();if(i)if(Object.keys(i).length){u.$_terms.keys=u.$_terms.keys?u.$_terms.keys.filter(f=>!i.hasOwnProperty(f.key)):new s.Keys;for(const f in i)a.tryWithPath(()=>u.$_terms.keys.push({key:f,schema:this.$_compile(i[f])}),f)}else u.$_terms.keys=new s.Keys;else u.$_terms.keys=null;return u.$_mutateRebuild()}},length:{method(i){return this.$_addRule({name:"length",args:{limit:i},operator:"="})},validate:(i,u,{limit:f},{name:h,operator:v,args:_})=>a.compare(Object.keys(i).length,f,v)?i:u.error("object."+h,{limit:_.limit,value:i}),args:[{name:"limit",ref:!0,assert:a.limit,message:"must be a positive integer"}]},max:{method(i){return this.$_addRule({name:"max",method:"length",args:{limit:i},operator:"<="})}},min:{method(i){return this.$_addRule({name:"min",method:"length",args:{limit:i},operator:">="})}},nand:{method(...i){return a.verifyFlat(i,"nand"),s.dependency(this,"nand",null,i)}},or:{method(...i){return a.verifyFlat(i,"or"),s.dependency(this,"or",null,i)}},oxor:{method(...i){return s.dependency(this,"oxor",null,i)}},pattern:{method(i,u,f={}){const h=i instanceof RegExp;h||(i=this.$_compile(i,{appendPath:!0})),y(u!==void 0,"Invalid rule"),a.assertOptions(f,["fallthrough","matches"]),h&&y(!i.flags.includes("g")&&!i.flags.includes("y"),"pattern should not use global or sticky mode"),u=this.$_compile(u,{appendPath:!0});const v=this.clone();v.$_terms.patterns=v.$_terms.patterns||[];const _={[h?"regex":"schema"]:i,rule:u};return f.matches&&(_.matches=this.$_compile(f.matches),_.matches.type!=="array"&&(_.matches=_.matches.$_root.array().items(_.matches)),v.$_mutateRegister(_.matches),v.$_setFlag("_hasPatternMatch",!0,{clone:!1})),f.fallthrough&&(_.fallthrough=!0),v.$_terms.patterns.push(_),v.$_mutateRegister(u),v}},ref:{method(){return this.$_addRule("ref")},validate:(i,u)=>e.isRef(i)?i:u.error("object.refType",{value:i})},regex:{method(){return this.$_addRule("regex")},validate:(i,u)=>i instanceof RegExp?i:u.error("object.regex",{value:i})},rename:{method(i,u,f={}){y(typeof i=="string"||i instanceof RegExp,"Rename missing the from argument"),y(typeof u=="string"||u instanceof l,"Invalid rename to argument"),y(u!==i,"Cannot rename key to same name:",i),a.assertOptions(f,["alias","ignoreUndefined","override","multiple"]);const h=this.clone();h.$_terms.renames=h.$_terms.renames||[];for(const v of h.$_terms.renames)y(v.from!==i,"Cannot rename the same key multiple times");return u instanceof l&&h.$_mutateRegister(u),h.$_terms.renames.push({from:i,to:u,options:o(s.renameDefaults,f)}),h}},schema:{method(i="any"){return this.$_addRule({name:"schema",args:{type:i}})},validate:(i,u,{type:f})=>!a.isSchema(i)||f!=="any"&&i.type!==f?u.error("object.schema",{type:f}):i},unknown:{method(i){return this.$_setFlag("unknown",i!==!1)}},with:{method(i,u,f={}){return s.dependency(this,"with",i,u,f)}},without:{method(i,u,f={}){return s.dependency(this,"without",i,u,f)}},xor:{method(...i){return a.verifyFlat(i,"xor"),s.dependency(this,"xor",null,i)}}},overrides:{default(i,u){return i===void 0&&(i=a.symbols.deepDefault),this.$_parent("default",i,u)},isAsync(){var i,u,f;if((i=this.$_terms.externals)!==null&&i!==void 0&&i.length)return!0;if((u=this.$_terms.keys)!==null&&u!==void 0&&u.length){for(const h of this.$_terms.keys)if(h.schema.isAsync())return!0}if((f=this.$_terms.patterns)!==null&&f!==void 0&&f.length){for(const h of this.$_terms.patterns)if(h.rule.isAsync())return!0}return!1}},rebuild(i){if(i.$_terms.keys){const u=new p.Sorter;for(const f of i.$_terms.keys)a.tryWithPath(()=>u.add(f,{after:f.schema.$_rootReferences(),group:f.key}),f.key);i.$_terms.keys=new s.Keys(...u.nodes)}},manifest:{build(i,u){if(u.keys&&(i=i.keys(u.keys)),u.dependencies)for(const{rel:f,key:h=null,peers:v,options:_}of u.dependencies)i=s.dependency(i,f,h,v,_);if(u.patterns)for(const{regex:f,schema:h,rule:v,fallthrough:_,matches:c}of u.patterns)i=i.pattern(f||h,v,{fallthrough:_,matches:c});if(u.renames)for(const{from:f,to:h,options:v}of u.renames)i=i.rename(f,h,v);return i}},messages:{"object.and":"{{#label}} contains {{#presentWithLabels}} without its required peers {{#missingWithLabels}}","object.assert":'{{#label}} is invalid because {if(#subject.key, `"` + #subject.key + `" failed to ` + (#message || "pass the assertion test"), #message || "the assertion failed")}',"object.base":"{{#label}} must be of type {{#type}}","object.instance":"{{#label}} must be an instance of {{:#type}}","object.length":'{{#label}} must have {{#limit}} key{if(#limit == 1, "", "s")}',"object.max":'{{#label}} must have less than or equal to {{#limit}} key{if(#limit == 1, "", "s")}',"object.min":'{{#label}} must have at least {{#limit}} key{if(#limit == 1, "", "s")}',"object.missing":"{{#label}} must contain at least one of {{#peersWithLabels}}","object.nand":"{{:#mainWithLabel}} must not exist simultaneously with {{#peersWithLabels}}","object.oxor":"{{#label}} contains a conflict between optional exclusive peers {{#peersWithLabels}}","object.pattern.match":"{{#label}} keys failed to match pattern requirements","object.refType":"{{#label}} must be a Joi reference","object.regex":"{{#label}} must be a RegExp object","object.rename.multiple":"{{#label}} cannot rename {{:#from}} because multiple renames are disabled and another key was already renamed to {{:#to}}","object.rename.override":"{{#label}} cannot rename {{:#from}} because override is disabled and target {{:#to}} exists","object.schema":"{{#label}} must be a Joi schema of {{#type}} type","object.unknown":"{{#label}} is not allowed","object.with":"{{:#mainWithLabel}} missing required peer {{:#peerWithLabel}}","object.without":"{{:#mainWithLabel}} conflict with forbidden peer {{:#peerWithLabel}}","object.xor":"{{#label}} contains a conflict between exclusive peers {{#peersWithLabels}}"}}),s.clone=function(i,u){if(typeof i=="object"){if(u.nonEnumerables)return b(i,{shallow:!0});const h=Object.create(Object.getPrototypeOf(i));return Object.assign(h,i),h}const f=function(...h){return i.apply(this,h)};return f.prototype=b(i.prototype),Object.defineProperty(f,"name",{value:i.name,writable:!1}),Object.defineProperty(f,"length",{value:i.length,writable:!1}),Object.assign(f,i),f},s.dependency=function(i,u,f,h,v){y(f===null||typeof f=="string",u,"key must be a strings"),v||(v=h.length>1&&typeof h[h.length-1]=="object"?h.pop():{}),a.assertOptions(v,["separator","isPresent"]),h=[].concat(h);const _=a.default(v.separator,"."),c=[];for(const d of h)y(typeof d=="string",u,"peers must be strings"),c.push(n.ref(d,{separator:_,ancestor:0,prefix:!1}));f!==null&&(f=n.ref(f,{separator:_,ancestor:0,prefix:!1}));const m=i.clone();return m.$_terms.dependencies=m.$_terms.dependencies||[],m.$_terms.dependencies.push(new s.Dependency(u,f,c,h,v)),m},s.dependencies={and(i,u,f,h,v){const _=[],c=[],m=u.peers.length,d=s.isPresent(u.options);for(const E of u.peers)d(E.resolve(f,h,v,null,{shadow:!1}))===!1?_.push(E.key):c.push(E.key);if(_.length!==m&&c.length!==m)return{code:"object.and",context:{present:c,presentWithLabels:s.keysToLabels(i,c),missing:_,missingWithLabels:s.keysToLabels(i,_)}}},nand(i,u,f,h,v){const _=[],c=s.isPresent(u.options);for(const E of u.peers)c(E.resolve(f,h,v,null,{shadow:!1}))&&_.push(E.key);if(_.length!==u.peers.length)return;const m=u.paths[0],d=u.paths.slice(1);return{code:"object.nand",context:{main:m,mainWithLabel:s.keysToLabels(i,m),peers:d,peersWithLabels:s.keysToLabels(i,d)}}},or(i,u,f,h,v){const _=s.isPresent(u.options);for(const c of u.peers)if(_(c.resolve(f,h,v,null,{shadow:!1})))return;return{code:"object.missing",context:{peers:u.paths,peersWithLabels:s.keysToLabels(i,u.paths)}}},oxor(i,u,f,h,v){const _=[],c=s.isPresent(u.options);for(const d of u.peers)c(d.resolve(f,h,v,null,{shadow:!1}))&&_.push(d.key);if(!_.length||_.length===1)return;const m={peers:u.paths,peersWithLabels:s.keysToLabels(i,u.paths)};return m.present=_,m.presentWithLabels=s.keysToLabels(i,_),{code:"object.oxor",context:m}},with(i,u,f,h,v){const _=s.isPresent(u.options);for(const c of u.peers)if(_(c.resolve(f,h,v,null,{shadow:!1}))===!1)return{code:"object.with",context:{main:u.key.key,mainWithLabel:s.keysToLabels(i,u.key.key),peer:c.key,peerWithLabel:s.keysToLabels(i,c.key)}}},without(i,u,f,h,v){const _=s.isPresent(u.options);for(const c of u.peers)if(_(c.resolve(f,h,v,null,{shadow:!1})))return{code:"object.without",context:{main:u.key.key,mainWithLabel:s.keysToLabels(i,u.key.key),peer:c.key,peerWithLabel:s.keysToLabels(i,c.key)}}},xor(i,u,f,h,v){const _=[],c=s.isPresent(u.options);for(const d of u.peers)c(d.resolve(f,h,v,null,{shadow:!1}))&&_.push(d.key);if(_.length===1)return;const m={peers:u.paths,peersWithLabels:s.keysToLabels(i,u.paths)};return _.length===0?{code:"object.missing",context:m}:(m.present=_,m.presentWithLabels=s.keysToLabels(i,_),{code:"object.xor",context:m})}},s.keysToLabels=function(i,u){return Array.isArray(u)?u.map(f=>i.$_mapLabels(f)):i.$_mapLabels(u)},s.isPresent=function(i){return typeof i.isPresent=="function"?i.isPresent:u=>u!==void 0},s.rename=function(i,u,f,h,v){const _={};for(const c of i.$_terms.renames){const m=[],d=typeof c.from!="string";if(d)for(const E in u){if(u[E]===void 0&&c.options.ignoreUndefined||E===c.to)continue;const R=c.from.exec(E);R&&m.push({from:E,to:c.to,match:R})}else!Object.prototype.hasOwnProperty.call(u,c.from)||u[c.from]===void 0&&c.options.ignoreUndefined||m.push(c);for(const E of m){const R=E.from;let w=E.to;if(w instanceof l&&(w=w.render(u,f,h,E.match)),R!==w){if(!c.options.multiple&&_[w]&&(v.push(i.$_createError("object.rename.multiple",u,{from:R,to:w,pattern:d},f,h)),h.abortEarly)||Object.prototype.hasOwnProperty.call(u,w)&&!c.options.override&&!_[w]&&(v.push(i.$_createError("object.rename.override",u,{from:R,to:w,pattern:d},f,h)),h.abortEarly))return!1;u[R]===void 0?delete u[w]:u[w]=u[R],_[w]=!0,c.options.alias||delete u[R]}}}return!0},s.unknown=function(i,u,f,h,v,_){if(i.$_terms.patterns){let c=!1;const m=i.$_terms.patterns.map(E=>{if(E.matches)return c=!0,[]}),d=[u,...v.ancestors];for(const E of f){const R=u[E],w=[...v.path,E];for(let N=0;N<i.$_terms.patterns.length;++N){const I=i.$_terms.patterns[N];if(I.regex){const B=I.regex.test(E);if(v.mainstay.tracer.debug(v,"rule",`pattern.${N}`,B?"pass":"error"),!B)continue}else if(!I.schema.$_match(E,v.nest(I.schema,`pattern.${N}`),_))continue;f.delete(E);const T=v.localize(w,d,{schema:I.rule,key:E}),D=I.rule.$_validate(R,T,_);if(D.errors){if(_.abortEarly)return{value:u,errors:D.errors};h.push(...D.errors)}if(I.matches&&m[N].push(E),u[E]=D.value,!I.fallthrough)break}}if(c)for(let E=0;E<m.length;++E){const R=m[E];if(!R)continue;const w=i.$_terms.patterns[E].matches,N=v.localize(v.path,d,w),I=w.$_validate(R,N,_);if(I.errors){const T=t.details(I.errors,{override:!1});T.matches=R;const D=i.$_createError("object.pattern.match",u,T,v,_);if(_.abortEarly)return{value:u,errors:D};h.push(D)}}}if(f.size&&(i.$_terms.keys||i.$_terms.patterns)){if(_.stripUnknown&&i._flags.unknown===void 0||_.skipFunctions){const c=!(!_.stripUnknown||_.stripUnknown!==!0&&!_.stripUnknown.objects);for(const m of f)c?(delete u[m],f.delete(m)):typeof u[m]=="function"&&f.delete(m)}if(!a.default(i._flags.unknown,_.allowUnknown))for(const c of f){const m=v.localize([...v.path,c],[]),d=i.$_createError("object.unknown",u[c],{child:c},m,_,{flags:!1});if(_.abortEarly)return{value:u,errors:d};h.push(d)}}},s.Dependency=class{constructor(i,u,f,h,v){this.rel=i,this.key=u,this.peers=f,this.paths=h,this.options=v}describe(){const i={rel:this.rel,peers:this.paths};return this.key!==null&&(i.key=this.key.key),this.peers[0].separator!=="."&&(i.options={...i.options,separator:this.peers[0].separator}),this.options.isPresent&&(i.options={...i.options,isPresent:this.options.isPresent}),i}},s.Keys=class extends Array{concat(i){const u=this.slice(),f=new Map;for(let h=0;h<u.length;++h)f.set(u[h].key,h);for(const h of i){const v=h.key,_=f.get(v);_!==void 0?u[_]={key:v,schema:u[_].schema.concat(h.schema)}:u.push(h)}return u}}},3110:S=>{const A={};S.exports=function(g,o,y={}){if(!g||!o)return y.first?null:[];const b=[],p=Array.isArray(g)?new Set(g):g,r=new Set;for(const a of o)if(A.has(p,a)&&!r.has(a)){if(y.first)return a;b.push(a),r.add(a)}return y.first?null:b},A.has=function(g,o){return typeof g.has=="function"?g.has(o):g[o]!==void 0}},3115:(S,A,g)=>{A.applyToDefaults=g(6084),A.assert=g(8253),A.AssertError=g(1803),A.Bench=g(9145),A.block=g(3386),A.clone=g(4126),A.contain=g(2847),A.deepEqual=g(7125),A.escapeHeaderAttribute=g(9241),A.escapeHtml=g(8121),A.escapeJson=g(5570),A.escapeRegex=g(8669),A.flatten=g(5553),A.ignore=g(9725),A.intersect=g(3110),A.isPromise=g(834),A.merge=g(9315),A.once=g(8762),A.reach=g(1528),A.reachTemplate=g(1626),A.stringify=g(8314),A.wait=g(7858)},3305:(S,A,g)=>{g.r(A),g.d(A,{analyzeDomain:()=>i,analyzeEmail:()=>c,errorCodes:()=>y,ipRegex:()=>Z,isDomainValid:()=>u,isEmailValid:()=>m,uriDecode:()=>J,uriRegex:()=>q,validateDomainOptions:()=>f});var o=g(8663);const y={EMPTY_STRING:"Address must be a non-empty string",FORBIDDEN_UNICODE:"Address contains forbidden Unicode characters",MULTIPLE_AT_CHAR:"Address cannot contain more than one @ character",MISSING_AT_CHAR:"Address must contain one @ character",EMPTY_LOCAL:"Address local part cannot be empty",ADDRESS_TOO_LONG:"Address too long",LOCAL_TOO_LONG:"Address local part too long",EMPTY_LOCAL_SEGMENT:"Address local part contains empty dot-separated segment",INVALID_LOCAL_CHARS:"Address local part contains invalid character",DOMAIN_NON_EMPTY_STRING:"Domain must be a non-empty string",DOMAIN_TOO_LONG:"Domain too long",DOMAIN_INVALID_UNICODE_CHARS:"Domain contains forbidden Unicode characters",DOMAIN_INVALID_CHARS:"Domain contains invalid character",DOMAIN_INVALID_TLDS_CHARS:"Domain contains invalid tld character",DOMAIN_SEGMENTS_COUNT:"Domain lacks the minimum required number of segments",DOMAIN_SEGMENTS_COUNT_MAX:"Domain contains too many segments",DOMAIN_FORBIDDEN_TLDS:"Domain uses forbidden TLD",DOMAIN_EMPTY_SEGMENT:"Domain contains empty dot-separated segment",DOMAIN_LONG_SEGMENT:"Domain contains dot-separated segment that is too long"};function b(O){return{code:O,error:y[O]}}const p=2,r=/[^\x00-\x7f]/,a=/[\x00-\x20@\:\/\\#!\$&\'\(\)\*\+,;=\?]/,n=/^[a-zA-Z](?:[a-zA-Z0-9\-]*[a-zA-Z0-9])?$/,t=/^[a-zA-Z0-9](?:[a-zA-Z0-9\-]*[a-zA-Z0-9])?$/,e=/^[a-zA-Z0-9_](?:[a-zA-Z0-9\-]*[a-zA-Z0-9])?$/,l=o.URL||URL;function s(O){return!!O.allow}function i(O,$={}){if(!O)return b("DOMAIN_NON_EMPTY_STRING");if(typeof O!="string")throw new Error("Invalid input: domain must be a string");if(O.length>256)return b("DOMAIN_TOO_LONG");if(r.test(O)){if($.allowUnicode===!1)return b("DOMAIN_INVALID_UNICODE_CHARS");O=O.normalize("NFC")}if(a.test(O))return b("DOMAIN_INVALID_CHARS");O=(function(C){C.includes("%")&&(C=C.replace(/%/g,"%25"));try{return new l(`http://${C}`).host}catch{return C}})(O),$.allowFullyQualified&&O[O.length-1]==="."&&(O=O.slice(0,-1));const k=$.minDomainSegments||p,M=O.split(".");if(M.length<k)return b("DOMAIN_SEGMENTS_COUNT");if($.maxDomainSegments&&M.length>$.maxDomainSegments)return b("DOMAIN_SEGMENTS_COUNT_MAX");const L=$.tlds;if(L){const C=M[M.length-1].toLowerCase();if(s(L)){if(!L.allow.has(C))return b("DOMAIN_FORBIDDEN_TLDS")}else if(L.deny.has(C))return b("DOMAIN_FORBIDDEN_TLDS")}for(let C=0;C<M.length;++C){const P=M[C];if(!P.length)return b("DOMAIN_EMPTY_SEGMENT");if(P.length>63)return b("DOMAIN_LONG_SEGMENT");if(C<M.length-1){if($.allowUnderscore){if(!e.test(P))return b("DOMAIN_INVALID_CHARS")}else if(!t.test(P))return b("DOMAIN_INVALID_CHARS")}else if(!n.test(P))return b("DOMAIN_INVALID_TLDS_CHARS")}return null}function u(O,$){return!i(O,$)}function f(O){if(O){if(typeof O.tlds!="object")throw new Error("Invalid options: tlds must be a boolean or an object");if(s(O.tlds)){if(O.tlds.allow instanceof Set==0)throw new Error("Invalid options: tlds.allow must be a Set object or true");if(O.tlds.deny)throw new Error("Invalid options: cannot specify both tlds.allow and tlds.deny lists")}else if(O.tlds.deny instanceof Set==0)throw new Error("Invalid options: tlds.deny must be a Set object")}}var h=g(6984);const v=/[^\x00-\x7f]/,_=new(h.TextEncoder||TextEncoder);function c(O,$){return d(O,$)}function m(O,$){return!d(O,$)}function d(O,$={}){if(typeof O!="string")throw new Error("Invalid input: email must be a string");if(!O)return b("EMPTY_STRING");const k=!v.test(O);if(!k){if($.allowUnicode===!1)return b("FORBIDDEN_UNICODE");O=O.normalize("NFC")}const M=O.split("@");if(M.length!==2)return M.length>2?b("MULTIPLE_AT_CHAR"):b("MISSING_AT_CHAR");const[L,C]=M;if(!L)return b("EMPTY_LOCAL");if(!$.ignoreLength){if(O.length>254)return b("ADDRESS_TOO_LONG");if(_.encode(L).length>64)return b("LOCAL_TOO_LONG")}return(function(P,K){const X=P.split(".");for(const x of X){if(!x.length)return b("EMPTY_LOCAL_SEGMENT");if(K){if(!R.test(x))return b("INVALID_LOCAL_CHARS")}else for(const Y of x){if(R.test(Y))continue;const re=E(Y);if(!w.test(re))return b("INVALID_LOCAL_CHARS")}}return null})(L,k)||i(C,$)}function E(O){return Array.from(_.encode(O),$=>String.fromCharCode($)).join("")}const R=/^[\w!#\$%&'\*\+\-/=\?\^`\{\|\}~]+$/,w=new RegExp(["(?:[\\xc2-\\xdf][\\x80-\\xbf])","(?:\\xe0[\\xa0-\\xbf][\\x80-\\xbf])|(?:[\\xe1-\\xec][\\x80-\\xbf]{2})|(?:\\xed[\\x80-\\x9f][\\x80-\\xbf])|(?:[\\xee-\\xef][\\x80-\\xbf]{2})","(?:\\xf0[\\x90-\\xbf][\\x80-\\xbf]{2})|(?:[\\xf1-\\xf3][\\x80-\\xbf]{3})|(?:\\xf4[\\x80-\\x8f][\\x80-\\xbf]{2})"].join("|"));var N=g(8253),I=g.n(N),T=g(8669),D=g.n(T);const B=(function(){const O={},$="\\dA-Fa-f",k="["+$+"]",M="\\w-\\.~",L="!\\$&'\\(\\)\\*\\+,;=",C="%"+$,P=M+C+L+":@",K="["+P+"]",X="(?:0{0,2}\\d|0?[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])";O.ipv4address="(?:"+X+"\\.){3}"+X;const x=k+"{1,4}",Y="(?:"+x+":"+x+"|"+O.ipv4address+")",re="(?:"+x+":){6}"+Y,ye="::(?:"+x+":){5}"+Y,be="(?:"+x+")?::(?:"+x+":){4}"+Y,ve="(?:(?:"+x+":){0,1}"+x+")?::(?:"+x+":){3}"+Y,_e="(?:(?:"+x+":){0,2}"+x+")?::(?:"+x+":){2}"+Y,Ae="(?:(?:"+x+":){0,3}"+x+")?::"+x+":"+Y,Ee="(?:(?:"+x+":){0,4}"+x+")?::"+Y,Se="(?:(?:"+x+":){0,5}"+x+")?::"+x,Re="(?:(?:"+x+":){0,6}"+x+")?::";O.ipv4Cidr="(?:\\d|[1-2]\\d|3[0-2])",O.ipv6Cidr="(?:0{0,2}\\d|0?[1-9]\\d|1[01]\\d|12[0-8])",O.ipv6address="(?:"+re+"|"+ye+"|"+be+"|"+ve+"|"+_e+"|"+Ae+"|"+Ee+"|"+Se+"|"+Re+")",O.ipvFuture="v"+k+"+\\.["+M+L+":]+",O.scheme="[a-zA-Z][a-zA-Z\\d+-\\.]*",O.schemeRegex=new RegExp(O.scheme);const ie="["+M+C+L+":]*",Oe="["+M+C+L+"]{1,255}",oe="(?:\\[(?:"+O.ipv6address+"|"+O.ipvFuture+")\\]|"+O.ipv4address+"|"+Oe+")",le="(?:"+ie+"@)?"+oe+"(?::\\d*)?",ce="(?:"+ie+"@)?("+oe+")(?::\\d*)?",ue=K+"*",fe=K+"+",z="(?:\\/"+ue+")*",te="\\/(?:"+fe+z+")?",me=fe+z,he="["+M+C+L+"@]+"+z,we="(?:\\/\\/\\/"+ue+z+")";return O.hierPart="(?:(?:\\/\\/"+le+z+")|"+te+"|"+me+"|"+we+")",O.hierPartCapture="(?:(?:\\/\\/"+ce+z+")|"+te+"|"+me+")",O.relativeRef="(?:(?:\\/\\/"+le+z+")|"+te+"|"+he+"|)",O.relativeRefCapture="(?:(?:\\/\\/"+ce+z+")|"+te+"|"+he+"|)",O.query="["+P+"\\/\\?]*(?=#|$)",O.queryWithSquareBrackets="["+P+"\\[\\]\\/\\?]*(?=#|$)",O.fragment="["+P+"\\/\\?]*",O})(),F={v4Cidr:B.ipv4Cidr,v6Cidr:B.ipv6Cidr,ipv4:B.ipv4address,ipv6:B.ipv6address,ipvfuture:B.ipvFuture};function j(O){const $=B,k="(?:\\?"+(O.allowQuerySquareBrackets?$.queryWithSquareBrackets:$.query)+")?(?:#"+$.fragment+")?",M=O.domain?$.relativeRefCapture:$.relativeRef;if(O.relativeOnly)return U(M+k);let L="";if(O.scheme){I()(O.scheme instanceof RegExp||typeof O.scheme=="string"||Array.isArray(O.scheme),"scheme must be a RegExp, String, or Array");const P=[].concat(O.scheme);I()(P.length>=1,"scheme must have at least 1 scheme specified");const K=[];for(let X=0;X<P.length;++X){const x=P[X];I()(x instanceof RegExp||typeof x=="string","scheme at position "+X+" must be a RegExp or String"),x instanceof RegExp?K.push(x.source.toString()):(I()($.schemeRegex.test(x),"scheme at position "+X+" must be a valid scheme"),K.push(D()(x)))}L=K.join("|")}const C="(?:"+(L?"(?:"+L+")":$.scheme)+":"+(O.domain?$.hierPartCapture:$.hierPart)+")";return U((O.allowRelative?"(?:"+C+"|"+M+")":C)+k,L)}function U(O,$=null){return{raw:O=`(?=.)(?!https?:/(?:$|[^/]))(?!https?:///)(?!https?:[^/])${O}`,regex:new RegExp(`^${O}$`),scheme:$}}const H=j({});function q(O={}){return O.scheme||O.allowRelative||O.relativeOnly||O.allowQuerySquareBrackets||O.domain?j(O):H}function Z(O={}){const $=O.cidr||"optional";I()(["required","optional","forbidden"].includes($),"options.cidr must be one of required, optional, forbidden"),I()(O.version===void 0||typeof O.version=="string"||Array.isArray(O.version),"options.version must be a string or an array of string");let k=O.version||["ipv4","ipv6","ipvfuture"];Array.isArray(k)||(k=[k]),I()(k.length>=1,"options.version must have at least 1 version specified");for(const C of k)I()(typeof C=="string"&&C===C.toLowerCase(),"Invalid options.version value"),I()(["ipv4","ipv6","ipvfuture"].includes(C),"options.version contains unknown version "+C+" - must be one of ipv4, ipv6, ipvfuture");k=Array.from(new Set(k));const M=`(?:${k.map(C=>{if($==="forbidden")return F[C];const P=`\\/${C==="ipv4"?F.v4Cidr:F.v6Cidr}`;return $==="required"?`${F[C]}${P}`:`${F[C]}(?:${P})?`}).join("|")})`,L=new RegExp(`^${M}$`);return{cidr:$,versions:k,regex:L,raw:M}}const Q={0:0,1:1,2:2,3:3,4:4,5:5,6:6,7:7,8:8,9:9,a:10,A:10,b:11,B:11,c:12,C:12,d:13,D:13,e:14,E:14,f:15,F:15},V={accept:12,reject:0,data:[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4,4,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,6,7,7,7,7,7,7,7,7,7,7,7,7,8,7,7,10,9,9,9,11,4,4,4,4,4,4,4,4,4,4,4,0,0,0,0,0,0,0,0,0,0,0,0,12,0,0,0,0,24,36,48,60,72,84,96,0,12,12,12,0,0,0,0,0,0,0,0,0,0,0,24,0,0,0,0,0,0,0,0,0,24,24,24,0,0,0,0,0,0,0,0,0,24,24,0,0,0,0,0,0,0,0,0,0,48,48,48,0,0,0,0,0,0,0,0,0,0,48,48,0,0,0,0,0,0,0,0,0,48,0,0,0,0,0,0,0,0,0,0,127,63,63,63,0,31,15,15,15,7,7,7]};function J(O){let $=O.indexOf("%");if($===-1)return O;let k="",M=0,L=0,C=$,P=V.accept;for(;$>-1&&$<O.length;){const K=ae(O[$+1],4)|ae(O[$+2],0),X=V.data[K];if(P=V.data[256+P+X],L=L<<6|K&V.data[364+X],P!==V.accept){if(P===V.reject||($+=3,$>=O.length||O[$]!=="%"))return null}else k+=O.slice(M,C),k+=L<=65535?String.fromCharCode(L):String.fromCharCode(55232+(L>>10),56320+(1023&L)),L=0,M=$+3,$=O.indexOf("%",M),C=$}return k+O.slice(M)}function ae(O,$){const k=Q[O];return k===void 0?255:k<<$}},3386:(S,A,g)=>{const o=g(9725);S.exports=function(){return new Promise(o)}},3541:(S,A,g)=>{const{assert:o}=g(3115),y=g(9415),b=g(8529),p={};A.schema=function(r,a,n={}){y.assertOptions(n,["appendPath","override"]);try{return p.schema(r,a,n)}catch(t){throw n.appendPath&&t.path!==void 0&&(t.message=`${t.message} (${t.path})`),t}},p.schema=function(r,a,n){o(a!==void 0,"Invalid undefined schema"),Array.isArray(a)&&(o(a.length,"Invalid empty array schema"),a.length===1&&(a=a[0]));const t=(e,...l)=>n.override!==!1?e.valid(r.override,...l):e.valid(...l);if(p.simple(a))return t(r,a);if(typeof a=="function")return r.custom(a);if(o(typeof a=="object","Invalid schema content:",typeof a),y.isResolvable(a))return t(r,a);if(y.isSchema(a))return a;if(Array.isArray(a)){for(const e of a)if(!p.simple(e))return r.alternatives().try(...a);return t(r,...a)}return a instanceof RegExp?r.string().regex(a):a instanceof Date?t(r.date(),a):(o(Object.getPrototypeOf(a)===Object.getPrototypeOf({}),"Schema can only contain plain objects"),r.object().keys(a))},A.ref=function(r,a){return b.isRef(r)?r:b.create(r,a)},A.compile=function(r,a,n={}){y.assertOptions(n,["legacy"]);const t=a&&a[y.symbols.any];if(t)return o(n.legacy||t.version===y.version,"Cannot mix different versions of joi schemas:",t.version,y.version),a;if(typeof a!="object"||!n.legacy)return A.schema(r,a,{appendPath:!0});const e=p.walk(a);return e?e.compile(e.root,a):A.schema(r,a,{appendPath:!0})},p.walk=function(r){if(typeof r!="object")return null;if(Array.isArray(r)){for(const n of r){const t=p.walk(n);if(t)return t}return null}const a=r[y.symbols.any];if(a)return{root:r[a.root],compile:a.compile};o(Object.getPrototypeOf(r)===Object.getPrototypeOf({}),"Schema can only contain plain objects");for(const n in r){const t=p.walk(r[n]);if(t)return t}return null},p.simple=function(r){return r===null||["boolean","string","number"].includes(typeof r)},A.when=function(r,a,n){if(n===void 0&&(o(a&&typeof a=="object","Missing options"),n=a,a=b.create(".")),Array.isArray(n)&&(n={switch:n}),y.assertOptions(n,["is","not","then","otherwise","switch","break"]),y.isSchema(a))return o(n.is===void 0,'"is" can not be used with a schema condition'),o(n.not===void 0,'"not" can not be used with a schema condition'),o(n.switch===void 0,'"switch" can not be used with a schema condition'),p.condition(r,{is:a,then:n.then,otherwise:n.otherwise,break:n.break});if(o(b.isRef(a)||typeof a=="string","Invalid condition:",a),o(n.not===void 0||n.is===void 0,'Cannot combine "is" with "not"'),n.switch===void 0){let e=n;n.not!==void 0&&(e={is:n.not,then:n.otherwise,otherwise:n.then,break:n.break});let l=e.is!==void 0?r.$_compile(e.is):r.$_root.invalid(null,!1,0,"").required();return o(e.then!==void 0||e.otherwise!==void 0,'options must have at least one of "then", "otherwise", or "switch"'),o(e.break===void 0||e.then===void 0||e.otherwise===void 0,"Cannot specify then, otherwise, and break all together"),n.is===void 0||b.isRef(n.is)||y.isSchema(n.is)||(l=l.required()),p.condition(r,{ref:A.ref(a),is:l,then:e.then,otherwise:e.otherwise,break:e.break})}o(Array.isArray(n.switch),'"switch" must be an array'),o(n.is===void 0,'Cannot combine "switch" with "is"'),o(n.not===void 0,'Cannot combine "switch" with "not"'),o(n.then===void 0,'Cannot combine "switch" with "then"');const t={ref:A.ref(a),switch:[],break:n.break};for(let e=0;e<n.switch.length;++e){const l=n.switch[e],s=e===n.switch.length-1;y.assertOptions(l,s?["is","then","otherwise"]:["is","then"]),o(l.is!==void 0,'Switch statement missing "is"'),o(l.then!==void 0,'Switch statement missing "then"');const i={is:r.$_compile(l.is),then:r.$_compile(l.then)};if(b.isRef(l.is)||y.isSchema(l.is)||(i.is=i.is.required()),s){o(n.otherwise===void 0||l.otherwise===void 0,'Cannot specify "otherwise" inside and outside a "switch"');const u=n.otherwise!==void 0?n.otherwise:l.otherwise;u!==void 0&&(o(t.break===void 0,"Cannot specify both otherwise and break"),i.otherwise=r.$_compile(u))}t.switch.push(i)}return t},p.condition=function(r,a){for(const n of["then","otherwise"])a[n]===void 0?delete a[n]:a[n]=r.$_compile(a[n]);return a}},3738:(S,A)=>{const g={};A=S.exports={array:Array.prototype,buffer:!1,date:Date.prototype,error:Error.prototype,generic:Object.prototype,map:Map.prototype,promise:Promise.prototype,regex:RegExp.prototype,set:Set.prototype,url:URL.prototype,weakMap:WeakMap.prototype,weakSet:WeakSet.prototype},g.typeMap=new Map([["[object Error]",A.error],["[object Map]",A.map],["[object Promise]",A.promise],["[object Set]",A.set],["[object URL]",A.url],["[object WeakMap]",A.weakMap],["[object WeakSet]",A.weakSet]]),A.getInternalProto=function(o){if(Array.isArray(o))return A.array;if(o instanceof Date)return A.date;if(o instanceof RegExp)return A.regex;if(o instanceof Error)return A.error;const y=Object.prototype.toString.call(o);return g.typeMap.get(y)||A.generic}},4126:(S,A,g)=>{const o=g(1528),y=g(3738),b=g(86),p={needsProtoHack:new Set([y.set,y.map,y.weakSet,y.weakMap]),structuredCloneExists:typeof structuredClone=="function"};S.exports=p.clone=function(r,a={},n=null){if(typeof r!="object"||r===null)return r;let t=p.clone,e=n;if(a.shallow){if(a.shallow!==!0)return p.cloneWithShallow(r,a);t=u=>u}else if(e){const u=e.get(r);if(u)return u}else e=new Map;const l=y.getInternalProto(r);switch(l){case y.buffer:return(!1).from(r);case y.date:return new Date(r.getTime());case y.regex:case y.url:return new l.constructor(r)}const s=p.base(r,l,a);if(s===r)return r;if(e&&e.set(r,s),l===y.set)for(const u of r)s.add(t(u,a,e));else if(l===y.map)for(const[u,f]of r)s.set(u,t(f,a,e));const i=b.keys(r,a);for(const u of i){if(u==="__proto__")continue;if(l===y.array&&u==="length"){s.length=r.length;continue}if(p.structuredCloneExists&&l===y.error&&u==="stack")continue;const f=Object.getOwnPropertyDescriptor(r,u);f?f.get||f.set?Object.defineProperty(s,u,f):f.enumerable?s[u]=t(r[u],a,e):Object.defineProperty(s,u,{enumerable:!1,writable:!0,configurable:!0,value:t(r[u],a,e)}):Object.defineProperty(s,u,{enumerable:!0,writable:!0,configurable:!0,value:t(r[u],a,e)})}return s},p.cloneWithShallow=function(r,a){const n=a.shallow;(a=Object.assign({},a)).shallow=!1;const t=new Map;for(const e of n){const l=o(r,e);typeof l!="object"&&typeof l!="function"||t.set(l,l)}return p.clone(r,a,t)},p.base=function(r,a,n){if(n.prototype===!1)return p.needsProtoHack.has(a)?new a.constructor:a===y.array?[]:{};const t=Object.getPrototypeOf(r);if(t&&t.isImmutable)return r;if(a===y.array){const e=[];return t!==a&&Object.setPrototypeOf(e,t),e}if(a===y.error&&p.structuredCloneExists&&(t===a||Error.isPrototypeOf(t.constructor))){const e=structuredClone(r);return Object.getPrototypeOf(e)!==t&&Object.setPrototypeOf(e,t),e}if(p.needsProtoHack.has(a)){const e=new t.constructor;return t!==a&&Object.setPrototypeOf(e,t),e}return Object.create(t)}},4709:(S,A,g)=>{const{assert:o}=g(3115),y=g(680),b=g(9415),p={numberRx:/^\s*[+-]?(?:(?:\d+(?:\.\d*)?)|(?:\.\d+))(?:e([+-]?\d+))?\s*$/i,precisionRx:/(?:\.(\d+))?(?:[eE]([+-]?\d+))?$/,exponentialPartRegex:/[eE][+-]?\d+$/,leadingSignAndZerosRegex:/^[+-]?(0*)?/,dotRegex:/\./,trailingZerosRegex:/0+$/,decimalPlaces(r){const a=r.toString(),n=a.indexOf("."),t=a.indexOf("e");return(n<0?0:(t<0?a.length:t)-n-1)+(t<0?0:Math.max(0,-parseInt(a.slice(t+1))))}};S.exports=y.extend({type:"number",flags:{unsafe:{default:!1}},coerce:{from:"string",method(r,{schema:a,error:n}){if(!r.match(p.numberRx))return;r=r.trim();const t={value:parseFloat(r)};if(t.value===0&&(t.value=0),!a._flags.unsafe)if(r.match(/e/i)){if(p.extractSignificantDigits(r)!==p.extractSignificantDigits(String(t.value)))return t.errors=n("number.unsafe"),t}else{const e=t.value.toString();if(e.match(/e/i))return t;if(e!==p.normalizeDecimal(r))return t.errors=n("number.unsafe"),t}return t}},validate(r,{schema:a,error:n,prefs:t}){if(r===1/0||r===-1/0)return{value:r,errors:n("number.infinity")};if(!b.isNumber(r))return{value:r,errors:n("number.base")};const e={value:r};if(t.convert){const l=a.$_getRule("precision");if(l){const s=Math.pow(10,l.args.limit);e.value=Math.round(e.value*s)/s}}return e.value===0&&(e.value=0),!a._flags.unsafe&&(r>Number.MAX_SAFE_INTEGER||r<Number.MIN_SAFE_INTEGER)&&(e.errors=n("number.unsafe")),e},rules:{compare:{method:!1,validate:(r,a,{limit:n},{name:t,operator:e,args:l})=>b.compare(r,n,e)?r:a.error("number."+t,{limit:l.limit,value:r}),args:[{name:"limit",ref:!0,assert:b.isNumber,message:"must be a number"}]},greater:{method(r){return this.$_addRule({name:"greater",method:"compare",args:{limit:r},operator:">"})}},integer:{method(){return this.$_addRule("integer")},validate:(r,a)=>Math.trunc(r)-r===0?r:a.error("number.integer")},less:{method(r){return this.$_addRule({name:"less",method:"compare",args:{limit:r},operator:"<"})}},max:{method(r){return this.$_addRule({name:"max",method:"compare",args:{limit:r},operator:"<="})}},min:{method(r){return this.$_addRule({name:"min",method:"compare",args:{limit:r},operator:">="})}},multiple:{method(r){const a=typeof r=="number"?p.decimalPlaces(r):null,n=Math.pow(10,a);return this.$_addRule({name:"multiple",args:{base:r,baseDecimalPlace:a,pfactor:n}})},validate:(r,a,{base:n,baseDecimalPlace:t,pfactor:e},l)=>p.decimalPlaces(r)>t?a.error("number.multiple",{multiple:l.args.base,value:r}):Math.round(e*r)%Math.round(e*n)===0?r:a.error("number.multiple",{multiple:l.args.base,value:r}),args:[{name:"base",ref:!0,assert:r=>typeof r=="number"&&isFinite(r)&&r>0,message:"must be a positive number"},"baseDecimalPlace","pfactor"],multi:!0},negative:{method(){return this.sign("negative")}},port:{method(){return this.$_addRule("port")},validate:(r,a)=>Number.isSafeInteger(r)&&r>=0&&r<=65535?r:a.error("number.port")},positive:{method(){return this.sign("positive")}},precision:{method(r){return o(Number.isSafeInteger(r),"limit must be an integer"),this.$_addRule({name:"precision",args:{limit:r}})},validate(r,a,{limit:n}){const t=r.toString().match(p.precisionRx);return Math.max((t[1]?t[1].length:0)-(t[2]?parseInt(t[2],10):0),0)<=n?r:a.error("number.precision",{limit:n,value:r})},convert:!0},sign:{method(r){return o(["negative","positive"].includes(r),"Invalid sign",r),this.$_addRule({name:"sign",args:{sign:r}})},validate:(r,a,{sign:n})=>n==="negative"&&r<0||n==="positive"&&r>0?r:a.error(`number.${n}`)},unsafe:{method(r=!0){return o(typeof r=="boolean","enabled must be a boolean"),this.$_setFlag("unsafe",r)}}},cast:{string:{from:r=>typeof r=="number",to:(r,a)=>r.toString()}},messages:{"number.base":"{{#label}} must be a number","number.greater":"{{#label}} must be greater than {{#limit}}","number.infinity":"{{#label}} cannot be infinity","number.integer":"{{#label}} must be an integer","number.less":"{{#label}} must be less than {{#limit}}","number.max":"{{#label}} must be less than or equal to {{#limit}}","number.min":"{{#label}} must be greater than or equal to {{#limit}}","number.multiple":"{{#label}} must be a multiple of {{#multiple}}","number.negative":"{{#label}} must be a negative number","number.port":"{{#label}} must be a valid port","number.positive":"{{#label}} must be a positive number","number.precision":"{{#label}} must have no more than {{#limit}} decimal places","number.unsafe":"{{#label}} must be a safe number"}}),p.extractSignificantDigits=function(r){return r.replace(p.exponentialPartRegex,"").replace(p.dotRegex,"").replace(p.trailingZerosRegex,"").replace(p.leadingSignAndZerosRegex,"")},p.normalizeDecimal=function(r){return(r=r.replace(/^\+/,"").replace(/\.0*$/,"").replace(/^(-?)\.([^\.]*)$/,"$10.$2").replace(/^(-?)0+([0-9])/,"$1$2")).includes(".")&&r.endsWith("0")&&(r=r.replace(/0+$/,"")),r==="-0"?"0":r}},4840:(S,A,g)=>{const{assert:o}=g(3115),y=g(2888);S.exports=y.extend({type:"function",properties:{typeof:"function"},rules:{arity:{method(b){return o(Number.isSafeInteger(b)&&b>=0,"n must be a positive integer"),this.$_addRule({name:"arity",args:{n:b}})},validate:(b,p,{n:r})=>b.length===r?b:p.error("function.arity",{n:r})},class:{method(){return this.$_addRule("class")},validate:(b,p)=>/^\s*class\s/.test(b.toString())?b:p.error("function.class",{value:b})},minArity:{method(b){return o(Number.isSafeInteger(b)&&b>0,"n must be a strict positive integer"),this.$_addRule({name:"minArity",args:{n:b}})},validate:(b,p,{n:r})=>b.length>=r?b:p.error("function.minArity",{n:r})},maxArity:{method(b){return o(Number.isSafeInteger(b)&&b>=0,"n must be a positive integer"),this.$_addRule({name:"maxArity",args:{n:b}})},validate:(b,p,{n:r})=>b.length<=r?b:p.error("function.maxArity",{n:r})}},messages:{"function.arity":"{{#label}} must have an arity of {{#n}}","function.class":"{{#label}} must be a class","function.maxArity":"{{#label}} must have an arity lesser or equal to {{#n}}","function.minArity":"{{#label}} must have an arity greater or equal to {{#n}}"}})},4895:(S,A,g)=>{Object.defineProperty(A,"__esModule",{value:!0}),A.tlds=void 0;const o=g(362);A.tlds=new Set(o.TLDS.map(y=>y.toLowerCase()))},4957:(S,A,g)=>{const{clone:o,reach:y}=g(3115),b=g(9415),p={value:Symbol("value")};S.exports=p.State=class{constructor(r,a,n){this.path=r,this.ancestors=a,this.mainstay=n.mainstay,this.schemas=n.schemas,this.debug=null}localize(r,a=null,n=null){const t=new p.State(r,a,this);return n&&t.schemas&&(t.schemas=[p.schemas(n),...t.schemas]),t}nest(r,a){const n=new p.State(this.path,this.ancestors,this);return n.schemas=n.schemas&&[p.schemas(r),...n.schemas],n.debug=a,n}shadow(r,a){this.mainstay.shadow=this.mainstay.shadow||new p.Shadow,this.mainstay.shadow.set(this.path,r,a)}snapshot(){this.mainstay.shadow&&(this._snapshot=o(this.mainstay.shadow.node(this.path))),this.mainstay.snapshot()}restore(){this.mainstay.shadow&&(this.mainstay.shadow.override(this.path,this._snapshot),this._snapshot=void 0),this.mainstay.restore()}commit(){this.mainstay.shadow&&(this.mainstay.shadow.override(this.path,this._snapshot),this._snapshot=void 0),this.mainstay.commit()}},p.schemas=function(r){return b.isSchema(r)?{schema:r}:r},p.Shadow=class{constructor(){this._values=null}set(r,a,n){if(!r.length||n==="strip"&&typeof r[r.length-1]=="number")return;this._values=this._values||new Map;let t=this._values;for(let e=0;e<r.length;++e){const l=r[e];let s=t.get(l);s||(s=new Map,t.set(l,s)),t=s}t[p.value]=a}get(r){const a=this.node(r);if(a)return a[p.value]}node(r){if(this._values)return y(this._values,r,{iterables:!0})}override(r,a){if(!this._values)return;const n=r.slice(0,-1),t=r[r.length-1],e=y(this._values,n,{iterables:!0});a?e.set(t,a):e&&e.delete(t)}}},4972:(S,A,g)=>{const{assert:o,merge:y}=g(3115),b=g(680),p=g(9415),r=g(3541),a=g(8013),n=g(8529),t={};S.exports=b.extend({type:"alternatives",flags:{match:{default:"any"}},terms:{matches:{init:[],register:n.toSibling}},args:(e,...l)=>l.length===1&&Array.isArray(l[0])?e.try(...l[0]):e.try(...l),validate(e,l){const{schema:s,error:i,state:u,prefs:f}=l;if(s._flags.match){const v=[],_=[];for(let m=0;m<s.$_terms.matches.length;++m){const d=s.$_terms.matches[m],E=u.nest(d.schema,`match.${m}`);E.snapshot();const R=d.schema.$_validate(e,E,f);R.errors?(_.push(R.errors),E.restore()):(v.push(R.value),E.commit())}if(v.length===0)return{errors:i("alternatives.any",{details:_.map(m=>a.details(m,{override:!1}))})};if(s._flags.match==="one")return v.length===1?{value:v[0]}:{errors:i("alternatives.one")};if(v.length!==s.$_terms.matches.length)return{errors:i("alternatives.all",{details:_.map(m=>a.details(m,{override:!1}))})};const c=m=>m.$_terms.matches.some(d=>d.schema.type==="object"||d.schema.type==="alternatives"&&c(d.schema));return c(s)?{value:v.reduce((m,d)=>y(m,d,{mergeArrays:!1}))}:{value:v[v.length-1]}}const h=[];for(let v=0;v<s.$_terms.matches.length;++v){const _=s.$_terms.matches[v];if(_.schema){const d=u.nest(_.schema,`match.${v}`);d.snapshot();const E=_.schema.$_validate(e,d,f);if(!E.errors)return d.commit(),E;d.restore(),h.push({schema:_.schema,reports:E.errors});continue}const c=_.ref?_.ref.resolve(e,u,f):e,m=_.is?[_]:_.switch;for(let d=0;d<m.length;++d){const E=m[d],{is:R,then:w,otherwise:N}=E,I=`match.${v}${_.switch?"."+d:""}`;if(R.$_match(c,u.nest(R,`${I}.is`),f)){if(w)return w.$_validate(e,u.nest(w,`${I}.then`),f)}else if(N)return N.$_validate(e,u.nest(N,`${I}.otherwise`),f)}}return t.errors(h,l)},rules:{conditional:{method(e,l){o(!this._flags._endedSwitch,"Unreachable condition"),o(!this._flags.match,"Cannot combine match mode",this._flags.match,"with conditional rule"),o(l.break===void 0,"Cannot use break option with alternatives conditional");const s=this.clone(),i=r.when(s,e,l),u=i.is?[i]:i.switch;for(const f of u)if(f.then&&f.otherwise){s.$_setFlag("_endedSwitch",!0,{clone:!1});break}return s.$_terms.matches.push(i),s.$_mutateRebuild()}},match:{method(e){if(o(["any","one","all"].includes(e),"Invalid alternatives match mode",e),e!=="any")for(const l of this.$_terms.matches)o(l.schema,"Cannot combine match mode",e,"with conditional rules");return this.$_setFlag("match",e)}},try:{method(...e){o(e.length,"Missing alternative schemas"),p.verifyFlat(e,"try"),o(!this._flags._endedSwitch,"Unreachable condition");const l=this.clone();for(const s of e)l.$_terms.matches.push({schema:l.$_compile(s)});return l.$_mutateRebuild()}}},overrides:{label(e){return this.$_parent("label",e).$_modify({each:(l,s)=>s.path[0]!=="is"&&typeof l._flags.label!="string"?l.label(e):void 0,ref:!1})},isAsync(){var e;if((e=this.$_terms.externals)!==null&&e!==void 0&&e.length)return!0;for(const u of this.$_terms.matches){var l,s,i;if((l=u.schema)!==null&&l!==void 0&&l.isAsync()||(s=u.then)!==null&&s!==void 0&&s.isAsync()||(i=u.otherwise)!==null&&i!==void 0&&i.isAsync())return!0}return!1}},rebuild(e){e.$_modify({each:l=>{p.isSchema(l)&&l.type==="array"&&e.$_setFlag("_arrayItems",!0,{clone:!1})}})},manifest:{build(e,l){if(l.matches)for(const s of l.matches){const{schema:i,ref:u,is:f,not:h,then:v,otherwise:_}=s;e=i?e.try(i):u?e.conditional(u,{is:f,then:v,not:h,otherwise:_,switch:s.switch}):e.conditional(f,{then:v,otherwise:_})}return e}},messages:{"alternatives.all":"{{#label}} does not match all of the required types","alternatives.any":"{{#label}} does not match any of the allowed types","alternatives.match":"{{#label}} does not match any of the allowed types","alternatives.one":"{{#label}} matches more than one allowed type","alternatives.types":"{{#label}} must be one of {{#types}}"}}),t.errors=function(e,{error:l,state:s}){if(!e.length)return{errors:l("alternatives.any")};if(e.length===1)return{errors:e[0].reports};const i=new Set,u=[];for(const{reports:f,schema:h}of e){if(f.length>1)return t.unmatched(e,l);const v=f[0];if(v instanceof a.Report==0)return t.unmatched(e,l);if(v.state.path.length!==s.path.length){u.push({type:h.type,report:v});continue}if(v.code==="any.only"){for(const m of v.local.valids)i.add(m);continue}const[_,c]=v.code.split(".");c!=="base"?u.push({type:h.type,report:v}):v.code==="object.base"?i.add(v.local.type):i.add(_)}return u.length?u.length===1?{errors:u[0].report}:t.unmatched(e,l):{errors:l("alternatives.types",{types:[...i]})}},t.unmatched=function(e,l){const s=[];for(const i of e)s.push(...i.reports);return{errors:l("alternatives.match",a.details(s,{override:!1}))}}},5008:(S,A,g)=>{const{assert:o}=g(3115),y=g(680),b={};b.Map=class extends Map{slice(){return new b.Map(this)}},S.exports=y.extend({type:"symbol",terms:{map:{init:new b.Map}},coerce:{method(p,{schema:r,error:a}){const n=r.$_terms.map.get(p);return n&&(p=n),r._flags.only&&typeof p!="symbol"?{value:p,errors:a("symbol.map",{map:r.$_terms.map})}:{value:p}}},validate(p,{error:r}){if(typeof p!="symbol")return{value:p,errors:r("symbol.base")}},rules:{map:{method(p){p&&!p[Symbol.iterator]&&typeof p=="object"&&(p=Object.entries(p)),o(p&&p[Symbol.iterator],"Iterable must be an iterable or object");const r=this.clone(),a=[];for(const n of p){o(n&&n[Symbol.iterator],"Entry must be an iterable");const[t,e]=n;o(typeof t!="object"&&typeof t!="function"&&typeof t!="symbol","Key must not be of type object, function, or Symbol"),o(typeof e=="symbol","Value must be a Symbol"),r.$_terms.map.set(t,e),a.push(e)}return r.valid(...a)}}},manifest:{build:(p,r)=>(r.map&&(p=p.map(r.map)),p)},messages:{"symbol.base":"{{#label}} must be a symbol","symbol.map":"{{#label}} must be one of {{#map}}"}})},5553:S=>{const A={};S.exports=A.flatten=function(g,o){const y=o||[];for(const b of g)Array.isArray(b)?A.flatten(b,y):y.push(b);return y}},5570:S=>{const A={};S.exports=function(g){return g?g.replace(/[<>&\u2028\u2029]/g,A.escape):""},A.escape=function(g){return A.replacements.get(g)},A.replacements=new Map([["<","\\u003c"],[">","\\u003e"],["&","\\u0026"],["\u2028","\\u2028"],["\u2029","\\u2029"]])},5844:(S,A,g)=>{const{assert:o}=g(3115),y=g(9415),b=g(8529),p={};A.Ids=p.Ids=class{constructor(){this._byId=new Map,this._byKey=new Map,this._schemaChain=!1}clone(){const r=new p.Ids;return r._byId=new Map(this._byId),r._byKey=new Map(this._byKey),r._schemaChain=this._schemaChain,r}concat(r){r._schemaChain&&(this._schemaChain=!0);for(const[a,n]of r._byId.entries())o(!this._byKey.has(a),"Schema id conflicts with existing key:",a),this._byId.set(a,n);for(const[a,n]of r._byKey.entries())o(!this._byId.has(a),"Schema key conflicts with existing id:",a),this._byKey.set(a,n)}fork(r,a,n){const t=this._collect(r);t.push({schema:n});const e=t.shift();let l={id:e.id,schema:a(e.schema)};o(y.isSchema(l.schema),"adjuster function failed to return a joi schema type");for(const s of t)l={id:s.id,schema:p.fork(s.schema,l.id,l.schema)};return l.schema}labels(r,a=[]){const n=r[0],t=this._get(n);if(!t)return[...a,...r].join(".");const e=r.slice(1);return a=[...a,t.schema._flags.label||n],e.length?t.schema._ids.labels(e,a):a.join(".")}reach(r,a=[]){const n=r[0],t=this._get(n);o(t,"Schema does not contain path",[...a,...r].join("."));const e=r.slice(1);return e.length?t.schema._ids.reach(e,[...a,n]):t.schema}register(r,{key:a}={}){if(!r||!y.isSchema(r))return;(r.$_property("schemaChain")||r._ids._schemaChain)&&(this._schemaChain=!0);const n=r._flags.id;if(n){const t=this._byId.get(n);o(!t||t.schema===r,"Cannot add different schemas with the same id:",n),o(!this._byKey.has(n),"Schema id conflicts with existing key:",n),this._byId.set(n,{schema:r,id:n})}a&&(o(!this._byKey.has(a),"Schema already contains key:",a),o(!this._byId.has(a),"Schema key conflicts with existing id:",a),this._byKey.set(a,{schema:r,id:a}))}reset(){this._byId=new Map,this._byKey=new Map,this._schemaChain=!1}_collect(r,a=[],n=[]){const t=r[0],e=this._get(t);o(e,"Schema does not contain path",[...a,...r].join(".")),n=[e,...n];const l=r.slice(1);return l.length?e.schema._ids._collect(l,[...a,t],n):n}_get(r){return this._byId.get(r)||this._byKey.get(r)}},p.fork=function(r,a,n){const t=A.schema(r,{each:(e,{key:l})=>{if(a===(e._flags.id||l))return n},ref:!1});return t?t.$_mutateRebuild():r},A.schema=function(r,a){let n;for(const t in r._flags){if(t[0]==="_")continue;const e=p.scan(r._flags[t],{source:"flags",name:t},a);e!==void 0&&(n=n||r.clone(),n._flags[t]=e)}for(let t=0;t<r._rules.length;++t){const e=r._rules[t],l=p.scan(e.args,{source:"rules",name:e.name},a);if(l!==void 0){n=n||r.clone();const s=Object.assign({},e);s.args=l,n._rules[t]=s,n._singleRules.get(e.name)===e&&n._singleRules.set(e.name,s)}}for(const t in r.$_terms){if(t[0]==="_")continue;const e=p.scan(r.$_terms[t],{source:"terms",name:t},a);e!==void 0&&(n=n||r.clone(),n.$_terms[t]=e)}return n},p.scan=function(r,a,n,t,e){const l=t||[];if(r===null||typeof r!="object")return;let s;if(Array.isArray(r)){for(let i=0;i<r.length;++i){const u=a.source==="terms"&&a.name==="keys"&&r[i].key,f=p.scan(r[i],a,n,[i,...l],u);f!==void 0&&(s=s||r.slice(),s[i]=f)}return s}if(n.schema!==!1&&y.isSchema(r)||n.ref!==!1&&b.isRef(r)){const i=n.each(r,{...a,path:l,key:e});return i===r?void 0:i}for(const i in r){if(i[0]==="_")continue;const u=p.scan(r[i],a,n,[i,...l],e);u!==void 0&&(s=s||Object.assign({},r),s[i]=u)}return s}},6084:(S,A,g)=>{const o=g(8253),y=g(4126),b=g(9315),p=g(1528),r={};S.exports=function(a,n,t={}){if(o(a&&typeof a=="object","Invalid defaults value: must be an object"),o(!n||n===!0||typeof n=="object","Invalid source value: must be true, falsy or an object"),o(typeof t=="object","Invalid options: must be an object"),!n)return null;if(t.shallow)return r.applyToDefaultsWithShallow(a,n,t);const e=y(a);if(n===!0)return e;const l=t.nullOverride!==void 0&&t.nullOverride;return b(e,n,{nullOverride:l,mergeArrays:!1})},r.applyToDefaultsWithShallow=function(a,n,t){const e=t.shallow;o(Array.isArray(e),"Invalid keys");const l=new Map,s=n===!0?null:new Set;for(let f of e){f=Array.isArray(f)?f:f.split(".");const h=p(a,f);h&&typeof h=="object"?l.set(h,s&&p(n,f)||h):s&&s.add(f)}const i=y(a,{},l);if(!s)return i;for(const f of s)r.reachCopy(i,n,f);const u=t.nullOverride!==void 0&&t.nullOverride;return b(i,n,{nullOverride:u,mergeArrays:!1})},r.reachCopy=function(a,n,t){for(const s of t){if(!(s in n))return;const i=n[s];if(typeof i!="object"||i===null)return;n=i}const e=n;let l=a;for(let s=0;s<t.length-1;++s){const i=t[s];typeof l[i]!="object"&&(l[i]={}),l=l[i]}l[t[t.length-1]]=e}},6162:(S,A,g)=>{const{assert:o,clone:y}=g(3115),b=g(1532);A.compile=function(p,r){if(typeof p=="string")return o(!r,"Cannot set single message string"),new b(p);if(b.isTemplate(p))return o(!r,"Cannot set single message template"),p;o(typeof p=="object"&&!Array.isArray(p),"Invalid message options"),r=r?y(r):{};for(let a in p){const n=p[a];if(a==="root"||b.isTemplate(n)){r[a]=n;continue}if(typeof n=="string"){r[a]=new b(n);continue}o(typeof n=="object"&&!Array.isArray(n),"Invalid message for",a);const t=a;for(a in r[t]=r[t]||{},n){const e=n[a];a==="root"||b.isTemplate(e)?r[t][a]=e:(o(typeof e=="string","Invalid message for",a,"in",t),r[t][a]=new b(e))}}return r},A.decompile=function(p){const r={};for(let a in p){const n=p[a];if(a==="root"){r.root=n;continue}if(b.isTemplate(n)){r[a]=n.describe({compact:!0});continue}const t=a;for(a in r[t]={},n){const e=n[a];a!=="root"?r[t][a]=e.describe({compact:!0}):r[t].root=e}}return r},A.merge=function(p,r){if(!p)return A.compile(r);if(!r)return p;if(typeof r=="string")return new b(r);if(b.isTemplate(r))return r;const a=y(p);for(let n in r){const t=r[n];if(n==="root"||b.isTemplate(t)){a[n]=t;continue}if(typeof t=="string"){a[n]=new b(t);continue}o(typeof t=="object"&&!Array.isArray(t),"Invalid message for",n);const e=n;for(n in a[e]=a[e]||{},t){const l=t[n];n==="root"||b.isTemplate(l)?a[e][n]=l:(o(typeof l=="string","Invalid message for",n,"in",e),a[e][n]=new b(l))}}return a}},6186:(S,A,g)=>{const{assert:o}=g(3115),y=g(680),b=g(9415),p=g(6220),r={isBool:function(a){return typeof a=="boolean"}};S.exports=y.extend({type:"boolean",flags:{sensitive:{default:!1}},terms:{falsy:{init:null,manifest:"values"},truthy:{init:null,manifest:"values"}},coerce(a,{schema:n}){if(typeof a!="boolean"){if(typeof a=="string"){const t=n._flags.sensitive?a:a.toLowerCase();a=t==="true"||t!=="false"&&a}return typeof a!="boolean"&&(a=n.$_terms.truthy&&n.$_terms.truthy.has(a,null,null,!n._flags.sensitive)||(!n.$_terms.falsy||!n.$_terms.falsy.has(a,null,null,!n._flags.sensitive))&&a),{value:a}}},validate(a,{error:n}){if(typeof a!="boolean")return{value:a,errors:n("boolean.base")}},rules:{truthy:{method(...a){b.verifyFlat(a,"truthy");const n=this.clone();n.$_terms.truthy=n.$_terms.truthy||new p;for(let t=0;t<a.length;++t){const e=a[t];o(e!==void 0,"Cannot call truthy with undefined"),n.$_terms.truthy.add(e)}return n}},falsy:{method(...a){b.verifyFlat(a,"falsy");const n=this.clone();n.$_terms.falsy=n.$_terms.falsy||new p;for(let t=0;t<a.length;++t){const e=a[t];o(e!==void 0,"Cannot call falsy with undefined"),n.$_terms.falsy.add(e)}return n}},sensitive:{method(a=!0){return this.$_setFlag("sensitive",a)}}},cast:{number:{from:r.isBool,to:(a,n)=>a?1:0},string:{from:r.isBool,to:(a,n)=>a?"true":"false"}},manifest:{build:(a,n)=>(n.truthy&&(a=a.truthy(...n.truthy)),n.falsy&&(a=a.falsy(...n.falsy)),a)},messages:{"boolean.base":"{{#label}} must be a boolean"}})},6220:(S,A,g)=>{const{assert:o,deepEqual:y}=g(3115),b=g(9415),p={};S.exports=p.Values=class{constructor(r,a){this._values=new Set(r),this._refs=new Set(a),this._lowercase=p.lowercases(r),this._override=!1}get length(){return this._values.size+this._refs.size}add(r,a){b.isResolvable(r)?this._refs.has(r)||(this._refs.add(r),a&&a.register(r)):this.has(r,null,null,!1)||(this._values.add(r),typeof r=="string"&&this._lowercase.set(r.toLowerCase(),r))}static merge(r,a,n){if(r=r||new p.Values,a){if(a._override)return a.clone();for(const t of[...a._values,...a._refs])r.add(t)}if(n)for(const t of[...n._values,...n._refs])r.remove(t);return r.length?r:null}remove(r){b.isResolvable(r)?this._refs.delete(r):(this._values.delete(r),typeof r=="string"&&this._lowercase.delete(r.toLowerCase()))}has(r,a,n,t){return!!this.get(r,a,n,t)}get(r,a,n,t){if(!this.length)return!1;if(this._values.has(r))return{value:r};if(typeof r=="string"&&r&&t){const e=this._lowercase.get(r.toLowerCase());if(e)return{value:e}}if(!this._refs.size&&typeof r!="object")return!1;if(typeof r=="object"){for(const e of this._values)if(y(e,r))return{value:e}}if(a)for(const e of this._refs){const l=e.resolve(r,a,n,null,{in:!0});if(l===void 0)continue;const s=e.in&&typeof l=="object"?Array.isArray(l)?l:Object.keys(l):[l];for(const i of s)if(typeof i==typeof r){if(t&&r&&typeof r=="string"){if(i.toLowerCase()===r.toLowerCase())return{value:i,ref:e}}else if(y(i,r))return{value:i,ref:e}}}return!1}override(){this._override=!0}values(r){if(r&&r.display){const a=[];for(const n of[...this._values,...this._refs])n!==void 0&&a.push(n);return a}return Array.from([...this._values,...this._refs])}clone(){const r=new p.Values(this._values,this._refs);return r._override=this._override,r}concat(r){o(!r._override,"Cannot concat override set of values");const a=new p.Values([...this._values,...r._values],[...this._refs,...r._refs]);return a._override=this._override,a}describe(){const r=[];this._override&&r.push({override:!0});for(const a of this._values.values())r.push(a&&typeof a=="object"?{value:a}:a);for(const a of this._refs.values())r.push(a.describe());return r}},p.Values.prototype[b.symbols.values]=!0,p.Values.prototype.slice=p.Values.prototype.clone,p.lowercases=function(r){const a=new Map;if(r)for(const n of r)typeof n=="string"&&a.set(n.toLowerCase(),n);return a}},6913:S=>{S.exports={version:"18.0.1"}},6984:()=>{},7125:(S,A,g)=>{const o=g(3738),y={mismatched:null};S.exports=function(b,p,r){return r=Object.assign({prototype:!0},r),!!y.isDeepEqual(b,p,r,[])},y.isDeepEqual=function(b,p,r,a){if(b===p)return b!==0||1/b==1/p;const n=typeof b;if(n!==typeof p||b===null||p===null)return!1;if(n==="function"){if(!r.deepFunction||b.toString()!==p.toString())return!1}else if(n!=="object")return b!=b&&p!=p;const t=y.getSharedType(b,p,!!r.prototype);switch(t){case o.buffer:return!1;case o.promise:return b===p;case o.regex:case o.url:return b.toString()===p.toString();case y.mismatched:return!1}for(let e=a.length-1;e>=0;--e)if(a[e].isSame(b,p))return!0;a.push(new y.SeenEntry(b,p));try{return!!y.isDeepEqualObj(t,b,p,r,a)}finally{a.pop()}},y.getSharedType=function(b,p,r){if(r)return Object.getPrototypeOf(b)!==Object.getPrototypeOf(p)?y.mismatched:o.getInternalProto(b);const a=o.getInternalProto(b);return a!==o.getInternalProto(p)?y.mismatched:a},y.valueOf=function(b){const p=b.valueOf;if(p===void 0)return b;try{return p.call(b)}catch(r){return r}},y.hasOwnEnumerableProperty=function(b,p){return Object.prototype.propertyIsEnumerable.call(b,p)},y.isSetSimpleEqual=function(b,p){for(const r of Set.prototype.values.call(b))if(!Set.prototype.has.call(p,r))return!1;return!0},y.isDeepEqualObj=function(b,p,r,a,n){const{isDeepEqual:t,valueOf:e,hasOwnEnumerableProperty:l}=y,{keys:s,getOwnPropertySymbols:i}=Object;if(b===o.array){if(!a.part){if(p.length!==r.length)return!1;for(let c=0;c<p.length;++c)if(!t(p[c],r[c],a,n))return!1;return!0}for(const c of p)for(const m of r)if(t(c,m,a,n))return!0}else if(b===o.set){if(p.size!==r.size)return!1;if(!y.isSetSimpleEqual(p,r)){const c=new Set(Set.prototype.values.call(r));for(const m of Set.prototype.values.call(p)){if(c.delete(m))continue;let d=!1;for(const E of c)if(t(m,E,a,n)){c.delete(E),d=!0;break}if(!d)return!1}}}else if(b===o.map){if(p.size!==r.size)return!1;for(const[c,m]of Map.prototype.entries.call(p))if(m===void 0&&!Map.prototype.has.call(r,c)||!t(m,Map.prototype.get.call(r,c),a,n))return!1}else if(b===o.error&&(p.name!==r.name||p.message!==r.message))return!1;const u=e(p),f=e(r);if((p!==u||r!==f)&&!t(u,f,a,n))return!1;const h=s(p);if(!a.part&&h.length!==s(r).length&&!a.skip)return!1;let v=0;for(const c of h)if(a.skip&&a.skip.includes(c))r[c]===void 0&&++v;else if(!l(r,c)||!t(p[c],r[c],a,n))return!1;if(!a.part&&h.length-v!==s(r).length)return!1;if(a.symbols!==!1){const c=i(p),m=new Set(i(r));for(const d of c){var _;if((_=a.skip)===null||_===void 0||!_.includes(d)){if(l(p,d)){if(!l(r,d)||!t(p[d],r[d],a,n))return!1}else if(l(r,d))return!1}m.delete(d)}for(const d of m)if(l(r,d))return!1}return!0},y.SeenEntry=class{constructor(b,p){this.obj=b,this.ref=p}isSame(b,p){return this.obj===b&&this.ref===p}}},7487:(S,A,g)=>{const o=g(2888);S.exports=o.extend({type:"object",cast:{map:{from:y=>y&&typeof y=="object",to:(y,b)=>new Map(Object.entries(y))}}})},7858:S=>{S.exports=function(A,g,o){if(typeof A=="bigint"&&(A=Number(A)),A>=Number.MAX_SAFE_INTEGER&&(A=1/0),typeof A!="number"&&A!==void 0)throw new TypeError("Timeout must be a number or bigint");return new Promise(y=>{const b=o?o.setTimeout:setTimeout,p=()=>{const r=Math.min(A,2147483647);A-=r,b(()=>A>0?p():y(g),r)};A!==1/0&&p()})}},8013:(S,A,g)=>{const o=g(554),y=g(9415),b=g(1532);A.Report=class{constructor(p,r,a,n,t,e,l){if(this.code=p,this.flags=n,this.messages=t,this.path=e.path,this.prefs=l,this.state=e,this.value=r,this.message=null,this.template=null,this.local=a||{},this.local.label=A.label(this.flags,this.state,this.prefs,this.messages),this.value===void 0||this.local.hasOwnProperty("value")||(this.local.value=this.value),this.path.length){const s=this.path[this.path.length-1];typeof s!="object"&&(this.local.key=s)}}_setTemplate(p){if(this.template=p,!this.flags.label&&this.path.length===0){const r=this._template(this.template,"root");r&&(this.local.label=r)}}toString(){if(this.message)return this.message;const p=this.code;if(!this.prefs.errors.render)return this.code;const r=this._template(this.template)||this._template(this.prefs.messages)||this._template(this.messages);return r===void 0?`Error code "${p}" is not defined, your custom type is missing the correct messages definition`:(this.message=r.render(this.value,this.state,this.prefs,this.local,{errors:this.prefs.errors,messages:[this.prefs.messages,this.messages]}),this.prefs.errors.label||(this.message=this.message.replace(/^"" /,"").trim()),this.message)}_template(p,r){return A.template(this.value,p,r||this.code,this.state,this.prefs)}},A.path=function(p){let r="";for(const a of p)typeof a!="object"&&(typeof a=="string"?(r&&(r+="."),r+=a):r+=`[${a}]`);return r},A.template=function(p,r,a,n,t){if(!r)return;if(b.isTemplate(r))return a!=="root"?r:null;let e=t.errors.language;if(y.isResolvable(e)&&(e=e.resolve(p,n,t)),e&&r[e]){if(r[e][a]!==void 0)return r[e][a];if(r[e]["*"]!==void 0)return r[e]["*"]}return r[a]?r[a]:r["*"]},A.label=function(p,r,a,n){if(!a.errors.label)return"";if(p.label)return p.label;let t=r.path;return a.errors.label==="key"&&r.path.length>1&&(t=r.path.slice(-1)),A.path(t)||A.template(null,a.messages,"root",r,a)||n&&A.template(null,n,"root",r,a)||"value"},A.process=function(p,r,a){if(!p)return null;const{override:n,message:t,details:e}=A.details(p);if(n)return n;if(a.errors.stack)return new A.ValidationError(t,e,r);const l=Error.stackTraceLimit;Error.stackTraceLimit=0;const s=new A.ValidationError(t,e,r);return Error.stackTraceLimit=l,s},A.details=function(p,r={}){let a=[];const n=[];for(const t of p){if(t instanceof Error){if(r.override!==!1)return{override:t};const l=t.toString();a.push(l),n.push({message:l,type:"override",context:{error:t}});continue}const e=t.toString();a.push(e),n.push({message:e,path:t.path.filter(l=>typeof l!="object"),type:t.code,context:t.local})}return a.length>1&&(a=[...new Set(a)]),{message:a.join(". "),details:n}},A.ValidationError=class extends Error{constructor(p,r,a){super(p),this._original=a,this.details=r}static isError(p){return p instanceof A.ValidationError}},A.ValidationError.prototype.isJoi=!0,A.ValidationError.prototype.name="ValidationError",A.ValidationError.prototype.annotate=o.error},8121:S=>{const A={};S.exports=function(g){if(!g)return"";let o="";for(let y=0;y<g.length;++y){const b=g.charCodeAt(y);A.isSafe(b)?o+=g[y]:o+=A.escapeHtmlChar(b)}return o},A.escapeHtmlChar=function(g){return A.namedHtml.get(g)||(g>=256?"&#"+g+";":`&#x${g.toString(16).padStart(2,"0")};`)},A.isSafe=function(g){return A.safeCharCodes.has(g)},A.namedHtml=new Map([[38,"&amp;"],[60,"&lt;"],[62,"&gt;"],[34,"&quot;"],[160,"&nbsp;"],[162,"&cent;"],[163,"&pound;"],[164,"&curren;"],[169,"&copy;"],[174,"&reg;"]]),A.safeCharCodes=(function(){const g=new Set;for(let o=32;o<123;++o)(o>=97||o>=65&&o<=90||o>=48&&o<=57||o===32||o===46||o===44||o===45||o===58||o===95)&&g.add(o);return g})()},8248:(S,A,g)=>{const{assert:o}=g(3115),y={};A.Sorter=class{constructor(){this._items=[],this.nodes=[]}add(b,p){var r,a,n,t;const e=[].concat((r=(p=p??{}).before)!==null&&r!==void 0?r:[]),l=[].concat((a=p.after)!==null&&a!==void 0?a:[]),s=(n=p.group)!==null&&n!==void 0?n:"?",i=(t=p.sort)!==null&&t!==void 0?t:0;o(!e.includes(s),`Item cannot come before itself: ${s}`),o(!e.includes("?"),"Item cannot come before unassociated items"),o(!l.includes(s),`Item cannot come after itself: ${s}`),o(!l.includes("?"),"Item cannot come after unassociated items"),Array.isArray(b)||(b=[b]);for(const u of b){const f={seq:this._items.length,sort:i,before:e,after:l,group:s,node:u};this._items.push(f)}if(!p.manual){const u=this._sort();o(u,"item",s!=="?"?`added into group ${s}`:"","created a dependencies error")}return this.nodes}merge(b){Array.isArray(b)||(b=[b]);for(const r of b)if(r)for(const a of r._items)this._items.push(Object.assign({},a));this._items.sort(y.mergeSort);for(let r=0;r<this._items.length;++r)this._items[r].seq=r;const p=this._sort();return o(p,"merge created a dependencies error"),this.nodes}sort(){const b=this._sort();return o(b,"sort created a dependencies error"),this.nodes}_sort(){const b={},p=Object.create(null),r=Object.create(null);for(const f of this._items){var a;const h=f.seq,v=f.group;r[v]=(a=r[v])!==null&&a!==void 0?a:[],r[v].push(h),b[h]=f.before;for(const _ of f.after){var n;p[_]=(n=p[_])!==null&&n!==void 0?n:[],p[_].push(h)}}for(const f in b){const h=[];for(const v in b[f]){var t;const _=b[f][v];r[_]=(t=r[_])!==null&&t!==void 0?t:[],h.push(...r[_])}b[f]=h}for(const f in p)if(r[f])for(const h of r[f])b[h].push(...p[f]);const e={};for(const f in b){const h=b[f];for(const v of h){var l;e[v]=(l=e[v])!==null&&l!==void 0?l:[],e[v].push(f)}}const s={},i=[];for(let f=0;f<this._items.length;++f){let h=f;if(e[f]){h=null;for(let v=0;v<this._items.length;++v){if(s[v]===!0)continue;e[v]||(e[v]=[]);const _=e[v].length;let c=0;for(let m=0;m<_;++m)s[e[v][m]]&&++c;if(c===_){h=v;break}}}h!==null&&(s[h]=!0,i.push(h))}if(i.length!==this._items.length)return!1;const u={};for(const f of this._items)u[f.seq]=f;this._items=[],this.nodes=[];for(const f of i){const h=u[f];this.nodes.push(h.node),this._items.push(h)}return!0}},y.mergeSort=(b,p)=>b.sort===p.sort?0:b.sort<p.sort?-1:1},8253:(S,A,g)=>{const o=g(1803),y=g(8314),b=S.exports=function(p,...r){if(p)return;if(r.length===1&&r[0]instanceof Error)throw r[0];const a=r.filter(n=>n!=="").map(n=>typeof n=="string"?n:n instanceof Error?n.message:y(n));throw new o(a.join(" "),b)}},8314:S=>{S.exports=function(...A){try{return JSON.stringify(...A)}catch(g){return"[Cannot display object: "+g.message+"]"}}},8529:(S,A,g)=>{const{assert:o,clone:y,reach:b}=g(3115),p=g(9415);let r;const a={symbol:Symbol("ref"),defaults:{adjust:null,in:!1,iterables:null,map:null,separator:".",type:"value"}};A.create=function(n,t={}){o(typeof n=="string","Invalid reference key:",n),p.assertOptions(t,["adjust","ancestor","in","iterables","map","prefix","render","separator"]),o(!t.prefix||typeof t.prefix=="object","options.prefix must be of type object");const e=Object.assign({},a.defaults,t);delete e.prefix;const l=e.separator,s=a.context(n,l,t.prefix);if(e.type=s.type,n=s.key,e.type==="value")if(s.root&&(o(!l||n[0]!==l,"Cannot specify relative path with root prefix"),e.ancestor="root",n||(n=null)),l&&l===n)n=null,e.ancestor=0;else if(e.ancestor!==void 0)o(!l||!n||n[0]!==l,"Cannot combine prefix with ancestor option");else{const[i,u]=a.ancestor(n,l);u&&(n=n.slice(u))===""&&(n=null),e.ancestor=i}return e.path=l?n===null?[]:n.split(l):[n],new a.Ref(e)},A.in=function(n,t={}){return A.create(n,{...t,in:!0})},A.isRef=function(n){return!!n&&!!n[p.symbols.ref]},a.Ref=class{constructor(n){o(typeof n=="object","Invalid reference construction"),p.assertOptions(n,["adjust","ancestor","in","iterables","map","path","render","separator","type","depth","key","root","display"]),o([!1,void 0].includes(n.separator)||typeof n.separator=="string"&&n.separator.length===1,"Invalid separator"),o(!n.adjust||typeof n.adjust=="function","options.adjust must be a function"),o(!n.map||Array.isArray(n.map),"options.map must be an array"),o(!n.map||!n.adjust,"Cannot set both map and adjust options"),Object.assign(this,a.defaults,n),o(this.type==="value"||this.ancestor===void 0,"Non-value references cannot reference ancestors"),Array.isArray(this.map)&&(this.map=new Map(this.map)),this.depth=this.path.length,this.key=this.path.length?this.path.join(this.separator):null,this.root=this.path[0],this.updateDisplay()}resolve(n,t,e,l,s={}){return o(!this.in||s.in,"Invalid in() reference usage"),this.type==="global"?this._resolve(e.context,t,s):this.type==="local"?this._resolve(l,t,s):this.ancestor?this.ancestor==="root"?this._resolve(t.ancestors[t.ancestors.length-1],t,s):(o(this.ancestor<=t.ancestors.length,"Invalid reference exceeds the schema root:",this.display),this._resolve(t.ancestors[this.ancestor-1],t,s)):this._resolve(n,t,s)}_resolve(n,t,e){let l;if(this.type==="value"&&t.mainstay.shadow&&e.shadow!==!1&&(l=t.mainstay.shadow.get(this.absolute(t))),l===void 0&&(l=b(n,this.path,{iterables:this.iterables,functions:!0})),this.adjust&&(l=this.adjust(l)),this.map){const s=this.map.get(l);s!==void 0&&(l=s)}return t.mainstay&&t.mainstay.tracer.resolve(t,this,l),l}toString(){return this.display}absolute(n){return[...n.path.slice(0,-this.ancestor),...this.path]}clone(){return new a.Ref(this)}describe(){const n={path:this.path};this.type!=="value"&&(n.type=this.type),this.separator!=="."&&(n.separator=this.separator),this.type==="value"&&this.ancestor!==1&&(n.ancestor=this.ancestor),this.map&&(n.map=[...this.map]);for(const t of["adjust","iterables","render"])this[t]!==null&&this[t]!==void 0&&(n[t]=this[t]);return this.in!==!1&&(n.in=!0),{ref:n}}updateDisplay(){const n=this.key!==null?this.key:"";if(this.type!=="value")return void(this.display=`ref:${this.type}:${n}`);if(!this.separator)return void(this.display=`ref:${n}`);if(!this.ancestor)return void(this.display=`ref:${this.separator}${n}`);if(this.ancestor==="root")return void(this.display=`ref:root:${n}`);if(this.ancestor===1)return void(this.display=`ref:${n||".."}`);const t=new Array(this.ancestor+1).fill(this.separator).join("");this.display=`ref:${t}${n||""}`}},a.Ref.prototype[p.symbols.ref]=!0,A.build=function(n){return(n=Object.assign({},a.defaults,n)).type==="value"&&n.ancestor===void 0&&(n.ancestor=1),new a.Ref(n)},a.context=function(n,t,e={}){if(n=n.trim(),e){const l=e.global===void 0?"$":e.global;if(l!==t&&n.startsWith(l))return{key:n.slice(l.length),type:"global"};const s=e.local===void 0?"#":e.local;if(s!==t&&n.startsWith(s))return{key:n.slice(s.length),type:"local"};const i=e.root===void 0?"/":e.root;if(i!==t&&n.startsWith(i))return{key:n.slice(i.length),type:"value",root:!0}}return{key:n,type:"value"}},a.ancestor=function(n,t){if(!t)return[1,0];if(n[0]!==t)return[1,0];if(n[1]!==t)return[0,1];let e=2;for(;n[e]===t;)++e;return[e-1,e]},A.toSibling=0,A.toParent=1,A.Manager=class{constructor(){this.refs=[]}register(n,t){if(n)if(t=t===void 0?A.toParent:t,Array.isArray(n))for(const e of n)this.register(e,t);else if(p.isSchema(n))for(const e of n._refs.refs)e.ancestor-t>=0&&this.refs.push({ancestor:e.ancestor-t,root:e.root});else A.isRef(n)&&n.type==="value"&&n.ancestor-t>=0&&this.refs.push({ancestor:n.ancestor-t,root:n.root}),r=r||g(1532),r.isTemplate(n)&&this.register(n.refs(),t)}get length(){return this.refs.length}clone(){const n=new A.Manager;return n.refs=y(this.refs),n}reset(){this.refs=[]}roots(){return this.refs.filter(n=>!n.ancestor).map(n=>n.root)}}},8663:()=>{},8669:S=>{S.exports=function(A){return A.replace(/[\^\$\.\*\+\-\?\=\!\:\|\\\/\(\)\[\]\{\}\,]/g,"\\$&")}},8762:S=>{const A=Symbol("wrapped");S.exports=function(g){if(g[A])return g;let o=!1;const y=function(...b){o||(o=!0,g(...b))};return y[A]=!0,y}},9017:()=>{},9033:(S,A,g)=>{const{assert:o,escapeRegex:y}=g(3115),{isDomainValid:b,isEmailValid:p,ipRegex:r,uriRegex:a}=g(3305),n=g(4895),t=g(680),e=g(9415),l={tlds:n.tlds instanceof Set&&{tlds:{allow:n.tlds,deny:null}},base64Regex:{true:{true:/^(?:[\w\-]{2}[\w\-]{2})*(?:[\w\-]{2}==|[\w\-]{3}=)?$/,false:/^(?:[A-Za-z0-9+\/]{2}[A-Za-z0-9+\/]{2})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)?$/},false:{true:/^(?:[\w\-]{2}[\w\-]{2})*(?:[\w\-]{2}(==)?|[\w\-]{3}=?)?$/,false:/^(?:[A-Za-z0-9+\/]{2}[A-Za-z0-9+\/]{2})*(?:[A-Za-z0-9+\/]{2}(==)?|[A-Za-z0-9+\/]{3}=?)?$/}},dataUriRegex:/^data:[\w+.-]+\/[\w+.-]+;((charset=[\w-]+|base64),)?(.*)$/,hexRegex:{withPrefix:/^0x[0-9a-f]+$/i,withOptionalPrefix:/^(?:0x)?[0-9a-f]+$/i,withoutPrefix:/^[0-9a-f]+$/i},ipRegex:r({cidr:"forbidden"}).regex,isoDurationRegex:/^P(?!$)(\d+Y)?(\d+M)?(\d+W)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?$/,guidBrackets:{"{":"}","[":"]","(":")","":""},guidVersions:{uuidv1:"1",uuidv2:"2",uuidv3:"3",uuidv4:"4",uuidv5:"5",uuidv6:"6",uuidv7:"7",uuidv8:"8"},guidSeparators:new Set([void 0,!0,!1,"-",":"]),normalizationForms:["NFC","NFD","NFKC","NFKD"]};S.exports=t.extend({type:"string",flags:{insensitive:{default:!1},truncate:{default:!1}},terms:{replacements:{init:null}},coerce:{from:"string",method(s,{schema:i,state:u,prefs:f}){const h=i.$_getRule("normalize");h&&(s=s.normalize(h.args.form));const v=i.$_getRule("case");v&&(s=v.args.direction==="upper"?s.toLocaleUpperCase():s.toLocaleLowerCase());const _=i.$_getRule("trim");if(_&&_.args.enabled&&(s=s.trim()),i.$_terms.replacements)for(const m of i.$_terms.replacements)s=s.replace(m.pattern,m.replacement);const c=i.$_getRule("hex");if(c&&c.args.options.byteAligned&&s.length%2!=0&&(s=`0${s}`),i.$_getRule("isoDate")){const m=l.isoDate(s);m&&(s=m)}if(i._flags.truncate){const m=i.$_getRule("max");if(m){let d=m.args.limit;if(e.isResolvable(d)&&(d=d.resolve(s,u,f),!e.limit(d)))return{value:s,errors:i.$_createError("any.ref",d,{ref:m.args.limit,arg:"limit",reason:"must be a positive integer"},u,f)};s=s.slice(0,d)}}return{value:s}}},validate(s,{schema:i,error:u}){if(typeof s!="string")return{value:s,errors:u("string.base")};if(s===""){const f=i.$_getRule("min");return f&&f.args.limit===0?void 0:{value:s,errors:u("string.empty")}}},rules:{alphanum:{method(){return this.$_addRule("alphanum")},validate:(s,i)=>/^[a-zA-Z0-9]+$/.test(s)?s:i.error("string.alphanum")},base64:{method(s={}){return e.assertOptions(s,["paddingRequired","urlSafe"]),s={urlSafe:!1,paddingRequired:!0,...s},o(typeof s.paddingRequired=="boolean","paddingRequired must be boolean"),o(typeof s.urlSafe=="boolean","urlSafe must be boolean"),this.$_addRule({name:"base64",args:{options:s}})},validate:(s,i,{options:u})=>l.base64Regex[u.paddingRequired][u.urlSafe].test(s)?s:i.error("string.base64")},case:{method(s){return o(["lower","upper"].includes(s),"Invalid case:",s),this.$_addRule({name:"case",args:{direction:s}})},validate:(s,i,{direction:u})=>u==="lower"&&s===s.toLocaleLowerCase()||u==="upper"&&s===s.toLocaleUpperCase()?s:i.error(`string.${u}case`),convert:!0},creditCard:{method(){return this.$_addRule("creditCard")},validate(s,i){let u=s.length,f=0,h=1;for(;u--;){const v=s.charAt(u)*h;f+=v-9*(v>9),h^=3}return f>0&&f%10==0?s:i.error("string.creditCard")}},dataUri:{method(s={}){return e.assertOptions(s,["paddingRequired"]),s={paddingRequired:!0,...s},o(typeof s.paddingRequired=="boolean","paddingRequired must be boolean"),this.$_addRule({name:"dataUri",args:{options:s}})},validate(s,i,{options:u}){const f=s.match(l.dataUriRegex);return f&&(!f[2]||f[2]!=="base64"||l.base64Regex[u.paddingRequired].false.test(f[3]))?s:i.error("string.dataUri")}},domain:{method(s){s&&e.assertOptions(s,["allowFullyQualified","allowUnicode","allowUnderscore","maxDomainSegments","minDomainSegments","tlds"]);const i=l.addressOptions(s);return this.$_addRule({name:"domain",args:{options:s},address:i})},validate:(s,i,u,{address:f})=>b(s,f)?s:i.error("string.domain")},email:{method(s={}){e.assertOptions(s,["allowFullyQualified","allowUnicode","ignoreLength","maxDomainSegments","minDomainSegments","multiple","separator","tlds"]),o(s.multiple===void 0||typeof s.multiple=="boolean","multiple option must be an boolean");const i=l.addressOptions(s),u=new RegExp(`\\s*[${s.separator?y(s.separator):","}]\\s*`);return this.$_addRule({name:"email",args:{options:s},regex:u,address:i})},validate(s,i,{options:u},{regex:f,address:h}){const v=u.multiple?s.split(f):[s],_=[];for(const c of v)p(c,h)||_.push(c);return _.length?i.error("string.email",{value:s,invalids:_}):s}},guid:{alias:"uuid",method(s={}){e.assertOptions(s,["version","separator","wrapper"]),o(s.wrapper===void 0||typeof s.wrapper=="boolean"||typeof s.wrapper=="string"&&typeof l.guidBrackets[s.wrapper]=="string",`"wrapper" must be true, false, or one of "${Object.keys(l.guidBrackets).filter(Boolean).join('", "')}"`);let i="";if(s.version){const _=[].concat(s.version);o(_.length>=1,"version must have at least 1 valid version specified");const c=new Set;for(let m=0;m<_.length;++m){const d=_[m];o(typeof d=="string","version at position "+m+" must be a string");const E=l.guidVersions[d.toLowerCase()];o(E,"version at position "+m+" must be one of "+Object.keys(l.guidVersions).join(", ")),o(!c.has(E),"version at position "+m+" must not be a duplicate"),i+=E,c.add(E)}}o(l.guidSeparators.has(s.separator),'separator must be one of true, false, "-", or ":"');const u=s.separator===void 0?"[:-]?":s.separator===!0?"[:-]":s.separator===!1?"[]?":`\\${s.separator}`;let f,h;s.wrapper===void 0?(f="[\\[{\\(]?",h="[\\]}\\)]?"):s.wrapper===!0?(f="[\\[{\\(]",h="[\\]}\\)]"):s.wrapper===!1?(f="",h=""):(f=y(s.wrapper),h=y(l.guidBrackets[s.wrapper]));const v=new RegExp(`^(${f})[0-9A-F]{8}(${u})[0-9A-F]{4}\\2?[${i||"0-9A-F"}][0-9A-F]{3}\\2?[${i?"89AB":"0-9A-F"}][0-9A-F]{3}\\2?[0-9A-F]{12}(${h})$`,"i");return this.$_addRule({name:"guid",args:{options:s},regex:v})},validate(s,i,u,{regex:f}){const h=f.exec(s);if(!h)return i.error("string.guid");const v=h[1],_=h[h.length-1];return(v||_)&&l.guidBrackets[v]!==_?i.error("string.guid"):s}},hex:{method(s={}){return e.assertOptions(s,["byteAligned","prefix"]),s={byteAligned:!1,prefix:!1,...s},o(typeof s.byteAligned=="boolean","byteAligned must be boolean"),o(typeof s.prefix=="boolean"||s.prefix==="optional",'prefix must be boolean or "optional"'),this.$_addRule({name:"hex",args:{options:s}})},validate:(s,i,{options:u})=>(u.prefix==="optional"?l.hexRegex.withOptionalPrefix:u.prefix===!0?l.hexRegex.withPrefix:l.hexRegex.withoutPrefix).test(s)?u.byteAligned&&s.length%2!=0?i.error("string.hexAlign"):s:i.error("string.hex")},hostname:{method(){return this.$_addRule("hostname")},validate:(s,i)=>b(s,{minDomainSegments:1})||l.ipRegex.test(s)?s:i.error("string.hostname")},insensitive:{method(){return this.$_setFlag("insensitive",!0)}},ip:{method(s={}){e.assertOptions(s,["cidr","version"]);const{cidr:i,versions:u,regex:f}=r(s),h=s.version?u:void 0;return this.$_addRule({name:"ip",args:{options:{cidr:i,version:h}},regex:f})},validate:(s,i,{options:u},{regex:f})=>f.test(s)?s:u.version?i.error("string.ipVersion",{value:s,cidr:u.cidr,version:u.version}):i.error("string.ip",{value:s,cidr:u.cidr})},isoDate:{method(){return this.$_addRule("isoDate")},validate:(s,{error:i})=>l.isoDate(s)?s:i("string.isoDate")},isoDuration:{method(){return this.$_addRule("isoDuration")},validate:(s,i)=>l.isoDurationRegex.test(s)?s:i.error("string.isoDuration")},length:{method(s,i){return l.length(this,"length",s,"=",i)},validate(s,i,{limit:u,encoding:f},{name:h,operator:v,args:_}){const c=!f&&s.length;return e.compare(c,u,v)?s:i.error("string."+h,{limit:_.limit,value:s,encoding:f})},args:[{name:"limit",ref:!0,assert:e.limit,message:"must be a positive integer"},"encoding"]},lowercase:{method(){return this.case("lower")}},max:{method(s,i){return l.length(this,"max",s,"<=",i)},args:["limit","encoding"]},min:{method(s,i){return l.length(this,"min",s,">=",i)},args:["limit","encoding"]},normalize:{method(s="NFC"){return o(l.normalizationForms.includes(s),"normalization form must be one of "+l.normalizationForms.join(", ")),this.$_addRule({name:"normalize",args:{form:s}})},validate:(s,{error:i},{form:u})=>s===s.normalize(u)?s:i("string.normalize",{value:s,form:u}),convert:!0},pattern:{alias:"regex",method(s,i={}){o(s instanceof RegExp,"regex must be a RegExp"),o(!s.flags.includes("g")&&!s.flags.includes("y"),"regex should not use global or sticky mode"),typeof i=="string"&&(i={name:i}),e.assertOptions(i,["invert","name"]);const u=["string.pattern",i.invert?".invert":"",i.name?".name":".base"].join("");return this.$_addRule({name:"pattern",args:{regex:s,options:i},errorCode:u})},validate:(s,i,{regex:u,options:f},{errorCode:h})=>u.test(s)^f.invert?s:i.error(h,{name:f.name,regex:u,value:s}),args:["regex","options"],multi:!0},replace:{method(s,i){typeof s=="string"&&(s=new RegExp(y(s),"g")),o(s instanceof RegExp,"pattern must be a RegExp"),o(typeof i=="string","replacement must be a String");const u=this.clone();return u.$_terms.replacements||(u.$_terms.replacements=[]),u.$_terms.replacements.push({pattern:s,replacement:i}),u}},token:{method(){return this.$_addRule("token")},validate:(s,i)=>/^\w+$/.test(s)?s:i.error("string.token")},trim:{method(s=!0){return o(typeof s=="boolean","enabled must be a boolean"),this.$_addRule({name:"trim",args:{enabled:s}})},validate:(s,i,{enabled:u})=>u&&s!==s.trim()?i.error("string.trim"):s,convert:!0},truncate:{method(s=!0){return o(typeof s=="boolean","enabled must be a boolean"),this.$_setFlag("truncate",s)}},uppercase:{method(){return this.case("upper")}},uri:{method(s={}){e.assertOptions(s,["allowRelative","allowQuerySquareBrackets","domain","relativeOnly","scheme","encodeUri"]),s.domain&&e.assertOptions(s.domain,["allowFullyQualified","allowUnicode","maxDomainSegments","minDomainSegments","tlds"]);const{regex:i,scheme:u}=a(s),f=s.domain?l.addressOptions(s.domain):null;return this.$_addRule({name:"uri",args:{options:s},regex:i,domain:f,scheme:u})},validate(s,i,{options:u},{regex:f,domain:h,scheme:v}){if(["http:/","https:/"].includes(s))return i.error("string.uri");let _=f.exec(s);if(!_&&i.prefs.convert&&u.encodeUri){const c=encodeURI(s);_=f.exec(c),_&&(s=c)}if(_){const c=_[1]||_[2];return!h||u.allowRelative&&!c||b(c,h)?s:i.error("string.domain",{value:c})}return u.relativeOnly?i.error("string.uriRelativeOnly"):u.scheme?i.error("string.uriCustomScheme",{scheme:v,value:s}):i.error("string.uri")}}},manifest:{build(s,i){if(i.replacements)for(const{pattern:u,replacement:f}of i.replacements)s=s.replace(u,f);return s}},messages:{"string.alphanum":"{{#label}} must only contain alpha-numeric characters","string.base":"{{#label}} must be a string","string.base64":"{{#label}} must be a valid base64 string","string.creditCard":"{{#label}} must be a credit card","string.dataUri":"{{#label}} must be a valid dataUri string","string.domain":"{{#label}} must contain a valid domain name","string.email":"{{#label}} must be a valid email","string.empty":"{{#label}} is not allowed to be empty","string.guid":"{{#label}} must be a valid GUID","string.hex":"{{#label}} must only contain hexadecimal characters","string.hexAlign":"{{#label}} hex decoded representation must be byte aligned","string.hostname":"{{#label}} must be a valid hostname","string.ip":"{{#label}} must be a valid ip address with a {{#cidr}} CIDR","string.ipVersion":"{{#label}} must be a valid ip address of one of the following versions {{#version}} with a {{#cidr}} CIDR","string.isoDate":"{{#label}} must be in iso format","string.isoDuration":"{{#label}} must be a valid ISO 8601 duration","string.length":"{{#label}} length must be {{#limit}} characters long","string.lowercase":"{{#label}} must only contain lowercase characters","string.max":"{{#label}} length must be less than or equal to {{#limit}} characters long","string.min":"{{#label}} length must be at least {{#limit}} characters long","string.normalize":"{{#label}} must be unicode normalized in the {{#form}} form","string.token":"{{#label}} must only contain alpha-numeric and underscore characters","string.pattern.base":"{{#label}} with value {:[.]} fails to match the required pattern: {{#regex}}","string.pattern.name":"{{#label}} with value {:[.]} fails to match the {{#name}} pattern","string.pattern.invert.base":"{{#label}} with value {:[.]} matches the inverted pattern: {{#regex}}","string.pattern.invert.name":"{{#label}} with value {:[.]} matches the inverted {{#name}} pattern","string.trim":"{{#label}} must not have leading or trailing whitespace","string.uri":"{{#label}} must be a valid uri","string.uriCustomScheme":"{{#label}} must be a valid uri with a scheme matching the {{#scheme}} pattern","string.uriRelativeOnly":"{{#label}} must be a valid relative uri","string.uppercase":"{{#label}} must only contain uppercase characters"}}),l.addressOptions=function(s){if(!s)return l.tlds||s;if(o(s.minDomainSegments===void 0||Number.isSafeInteger(s.minDomainSegments)&&s.minDomainSegments>0,"minDomainSegments must be a positive integer"),o(s.maxDomainSegments===void 0||Number.isSafeInteger(s.maxDomainSegments)&&s.maxDomainSegments>0,"maxDomainSegments must be a positive integer"),s.tlds===!1)return s;if(s.tlds===!0||s.tlds===void 0)return o(l.tlds,"Built-in TLD list disabled"),Object.assign({},s,l.tlds);o(typeof s.tlds=="object","tlds must be true, false, or an object");const i=s.tlds.deny;if(i)return Array.isArray(i)&&(s=Object.assign({},s,{tlds:{deny:new Set(i)}})),o(s.tlds.deny instanceof Set,"tlds.deny must be an array, Set, or boolean"),o(!s.tlds.allow,"Cannot specify both tlds.allow and tlds.deny lists"),l.validateTlds(s.tlds.deny,"tlds.deny"),s;const u=s.tlds.allow;return u?u===!0?(o(l.tlds,"Built-in TLD list disabled"),Object.assign({},s,l.tlds)):(Array.isArray(u)&&(s=Object.assign({},s,{tlds:{allow:new Set(u)}})),o(s.tlds.allow instanceof Set,"tlds.allow must be an array, Set, or boolean"),l.validateTlds(s.tlds.allow,"tlds.allow"),s):{...s,tlds:!1}},l.validateTlds=function(s,i){for(const u of s)o(b(u,{minDomainSegments:1,maxDomainSegments:1}),`${i} must contain valid top level domain names`)},l.isoDate=function(s){if(!e.isIsoDate(s))return null;/.*T.*[+-]\d\d$/.test(s)&&(s+="00");const i=new Date(s);return isNaN(i.getTime())?null:i.toISOString()},l.length=function(s,i,u,f,h){return o(!h||!1,"Invalid encoding:",h),s.$_addRule({name:i,method:"length",args:{limit:u,encoding:h},operator:f})}},9145:S=>{const A={};S.exports=A.Bench=class{constructor(){this.ts=0,this.reset()}reset(){this.ts=A.Bench.now()}elapsed(){return A.Bench.now()-this.ts}static now(){const g=process.hrtime();return 1e3*g[0]+g[1]/1e6}}},9241:(S,A,g)=>{const o=g(8253);S.exports=function(y){return o(/^[ \w\!#\$%&'\(\)\*\+,\-\.\/\:;<\=>\?@\[\]\^`\{\|\}~\"\\]*$/.test(y),"Bad attribute value ("+y+")"),y.replace(/\\/g,"\\\\").replace(/\"/g,'\\"')}},9315:(S,A,g)=>{const o=g(8253),y=g(4126),b=g(86),p={};S.exports=p.merge=function(r,a,n){if(o(r&&typeof r=="object","Invalid target value: must be an object"),o(a==null||typeof a=="object","Invalid source value: must be null, undefined, or an object"),!a)return r;if(n=Object.assign({nullOverride:!0,mergeArrays:!0},n),Array.isArray(a)){o(Array.isArray(r),"Cannot merge array onto an object"),n.mergeArrays||(r.length=0);for(let e=0;e<a.length;++e)r.push(y(a[e],{symbols:n.symbols}));return r}const t=b.keys(a,n);for(let e=0;e<t.length;++e){const l=t[e];if(l==="__proto__"||!Object.prototype.propertyIsEnumerable.call(a,l))continue;const s=a[l];if(s&&typeof s=="object"){if(r[l]===s)continue;!r[l]||typeof r[l]!="object"||Array.isArray(r[l])!==Array.isArray(s)||s instanceof Date||s instanceof RegExp?r[l]=y(s,{symbols:n.symbols}):p.merge(r[l],s,n)}else(s!=null||n.nullOverride)&&(r[l]=s)}return r}},9415:(S,A,g)=>{const{assert:o,AssertError:y}=g(3115),b=g(6913);let p,r;const a={isoDate:/^(?:[-+]\d{2})?(?:\d{4}(?!\d{2}\b))(?:(-?)(?:(?:0[1-9]|1[0-2])(?:\1(?:[12]\d|0[1-9]|3[01]))?|W(?:[0-4]\d|5[0-2])(?:-?[1-7])?|(?:00[1-9]|0[1-9]\d|[12]\d{2}|3(?:[0-5]\d|6[1-6])))(?![T]$|[T][\d]+Z$)(?:[T\s](?:(?:(?:[01]\d|2[0-3])(?:(:?)[0-5]\d)?|24\:?00)(?:[.,]\d+(?!:))?)(?:\2[0-5]\d(?:[.,]\d+)?)?(?:[Z]|(?:[+-])(?:[01]\d|2[0-3])(?::?[0-5]\d)?)?)?)?$/};A.version=b.version,A.defaults={abortEarly:!0,allowUnknown:!1,artifacts:!1,cache:!0,context:null,convert:!0,dateFormat:"iso",errors:{escapeHtml:!1,label:"path",language:null,render:!0,stack:!1,wrap:{label:'"',array:"[]"}},externals:!0,messages:{},nonEnumerables:!1,noDefaults:!1,presence:"optional",skipFunctions:!1,stripUnknown:!1,warnings:!1},A.symbols={any:Symbol.for("@hapi/joi/schema"),arraySingle:Symbol("arraySingle"),deepDefault:Symbol("deepDefault"),errors:Symbol("errors"),literal:Symbol("literal"),override:Symbol("override"),parent:Symbol("parent"),prefs:Symbol("prefs"),ref:Symbol("ref"),template:Symbol("template"),values:Symbol("values")},A.assertOptions=function(n,t,e="Options"){o(n&&typeof n=="object"&&!Array.isArray(n),"Options must be of type object");const l=Object.keys(n).filter(s=>!t.includes(s));o(l.length===0,`${e} contain unknown keys: ${l}`)},A.checkPreferences=function(n){r=r||g(1688);const t=r.preferences.validate(n);if(t.error)throw new y([t.error.details[0].message])},A.compare=function(n,t,e){switch(e){case"=":return n===t;case">":return n>t;case"<":return n<t;case">=":return n>=t;case"<=":return n<=t}},A.default=function(n,t){return n===void 0?t:n},A.isIsoDate=function(n){return a.isoDate.test(n)},A.isNumber=function(n){return typeof n=="number"&&!isNaN(n)},A.isResolvable=function(n){return!!n&&(n[A.symbols.ref]||n[A.symbols.template])},A.isSchema=function(n,t={}){const e=n&&n[A.symbols.any];return!!e&&(o(t.legacy||e.version===A.version,"Cannot mix different versions of joi schemas"),!0)},A.isValues=function(n){return n[A.symbols.values]},A.limit=function(n){return Number.isSafeInteger(n)&&n>=0},A.preferences=function(n,t){p=p||g(6162),n=n||{},t=t||{};const e=Object.assign({},n,t);return t.errors&&n.errors&&(e.errors=Object.assign({},n.errors,t.errors),e.errors.wrap=Object.assign({},n.errors.wrap,t.errors.wrap)),t.messages&&(e.messages=p.compile(t.messages,n.messages)),delete e[A.symbols.prefs],e},A.tryWithPath=function(n,t,e={}){try{return n()}catch(l){throw l.path!==void 0?l.path=t+"."+l.path:l.path=t,e.append&&(l.message=`${l.message} (${l.path})`),l}},A.validateArg=function(n,t,{assert:e,message:l}){if(A.isSchema(e)){const s=e.validate(n);return s.error?s.error.message:void 0}if(!e(n))return t?`${t} ${l}`:l},A.verifyFlat=function(n,t){for(const e of n)o(!Array.isArray(e),"Method no longer accepts array arguments:",t)}},9556:(S,A,g)=>{const{assert:o}=g(3115),y=g(680),b=g(9415),p=g(3541),r=g(8013),a={};S.exports=y.extend({type:"link",properties:{schemaChain:!0},terms:{link:{init:null,manifest:"single",register:!1}},args:(n,t)=>n.ref(t),validate(n,{schema:t,state:e,prefs:l}){o(t.$_terms.link,"Uninitialized link schema");const s=a.generate(t,n,e,l),i=t.$_terms.link[0].ref;return s.$_validate(n,e.nest(s,`link:${i.display}:${s.type}`),l)},generate:(n,t,e,l)=>a.generate(n,t,e,l),rules:{ref:{method(n){o(!this.$_terms.link,"Cannot reinitialize schema"),n=p.ref(n),o(n.type==="value"||n.type==="local","Invalid reference type:",n.type),o(n.type==="local"||n.ancestor==="root"||n.ancestor>0,"Link cannot reference itself");const t=this.clone();return t.$_terms.link=[{ref:n}],t}},relative:{method(n=!0){return this.$_setFlag("relative",n)}}},overrides:{concat(n){o(this.$_terms.link,"Uninitialized link schema"),o(b.isSchema(n),"Invalid schema object"),o(n.type!=="link","Cannot merge type link with another link");const t=this.clone();return t.$_terms.whens||(t.$_terms.whens=[]),t.$_terms.whens.push({concat:n}),t.$_mutateRebuild()}},manifest:{build:(n,t)=>(o(t.link,"Invalid link description missing link"),n.ref(t.link))}}),a.generate=function(n,t,e,l){let s=e.mainstay.links.get(n);if(s)return s._generate(t,e,l).schema;const i=n.$_terms.link[0].ref,{perspective:u,path:f}=a.perspective(i,e);a.assert(u,"which is outside of schema boundaries",i,n,e,l);try{s=f.length?u.$_reach(f):u}catch{a.assert(!1,"to non-existing schema",i,n,e,l)}return a.assert(s.type!=="link","which is another link",i,n,e,l),n._flags.relative||e.mainstay.links.set(n,s),s._generate(t,e,l).schema},a.perspective=function(n,t){if(n.type==="local"){for(const{schema:e,key:l}of t.schemas){if((e._flags.id||l)===n.path[0])return{perspective:e,path:n.path.slice(1)};if(e.$_terms.shared){for(const s of e.$_terms.shared)if(s._flags.id===n.path[0])return{perspective:s,path:n.path.slice(1)}}}return{perspective:null,path:null}}return n.ancestor==="root"?{perspective:t.schemas[t.schemas.length-1].schema,path:n.path}:{perspective:t.schemas[n.ancestor]&&t.schemas[n.ancestor].schema,path:n.path}},a.assert=function(n,t,e,l,s,i){n||o(!1,`"${r.label(l._flags,s,i)}" contains link reference "${e.display}" ${t}`)}},9725:S=>{S.exports=function(){}}},ee={};function W(S){var A=ee[S];if(A!==void 0)return A.exports;var g=ee[S]={exports:{}};return ne[S](g,g.exports,W),g.exports}return W.n=S=>{var A=S&&S.__esModule?()=>S.default:()=>S;return W.d(A,{a:A}),A},W.d=(S,A)=>{for(var g in A)W.o(A,g)&&!W.o(S,g)&&Object.defineProperty(S,g,{enumerable:!0,get:A[g]})},W.o=(S,A)=>Object.prototype.hasOwnProperty.call(S,A),W.r=S=>{typeof Symbol<"u"&&Symbol.toStringTag&&Object.defineProperty(S,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(S,"__esModule",{value:!0})},W(1100)})())})(se)),se.exports}var Te=Ce();const G=Ie(Te),pe=G.string().pattern(/^(?=.{8,}$)(?=.*\d)(?=.*[^A-Za-z0-9])[A-Z][^\s]{7,}$/).messages({"string.empty":"Password is required","string.pattern.base":"Password must be at least 8 characters, start with an uppercase letter, and include at least one number and symbol"}),je=G.object({username:G.string().min(3).max(30).required().messages({"string.empty":"Username is required","string.min":"Username must be at least 3 characters long","string.max":"Username cannot be more than 30 characters long"}),mobile:G.string().pattern(/^[6-9]\d{9}$/).required().messages({"string.empty":"Mobile number is required","string.pattern.base":"Enter a valid 10-digit Indian mobile number starting with 6-9"}),email:G.string().email({tlds:{allow:!1}}).required().messages({"string.empty":"Email is required","string.email":"Please enter a valid email address"}),password:pe,confirmPassword:G.any().valid(G.ref("password")).required().messages({"any.only":"Passwords do not match","any.required":"Please confirm your password"})}),ke=G.object({email:G.string().email({tlds:{allow:!1}}).required().messages({"string.empty":"Email is required","string.email":"Please enter a valid email address"}),password:G.string().required().messages({"string.empty":"Password is required"})}),Pe=G.object({fullName:G.string().min(3).max(120).required().messages({"string.empty":"Full name is required","string.min":"Full name must be at least 3 characters","string.max":"Full name cannot exceed 120 characters"}),companyName:G.string().min(2).max(150).required().messages({"string.empty":"Company name is required","string.min":"Company name must be at least 2 characters","string.max":"Company name cannot exceed 150 characters"}),companyEmail:G.string().email({tlds:{allow:!1}}).required().messages({"string.empty":"Company email is required","string.email":"Please enter a valid company email"}),contactNumber:G.string().pattern(/^[6-9]\d{9}$/).required().messages({"string.pattern.base":"Please enter a valid 10-digit mobile number","string.empty":"Company contact number is required"}),gstNumber:G.string().allow("",null).pattern(/^[0-9A-Z]{15}$/).messages({"string.pattern.base":"GST number must be 15 characters (alphanumeric)"}),location:G.string().min(3).max(200).required().messages({"string.empty":"Location is required","string.min":"Location must be at least 3 characters","string.max":"Location cannot exceed 200 characters"}),password:pe,confirmPassword:G.any().valid(G.ref("password")).required().messages({"any.only":"Passwords do not match","any.required":"Please confirm your password"})});export{Me as E,pe as a,Pe as b,ke as l,je as s};
